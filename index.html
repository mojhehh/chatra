
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Chatra</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Tailwind CSS (optional, for looks) -->
    <script>
      // Suppress Tailwind CDN production warning BEFORE loading
      window.tailwindConfig = {};
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

    <!-- Hide scrollbar but keep scrolling + custom animations / glassmorphism -->
    <style>
      #messages {
        scrollbar-width: thin;
        scrollbar-color: rgba(100, 116, 139, 0.6) rgba(15, 23, 42, 0.3);
      }
      #messages::-webkit-scrollbar {
        width: 8px;
      }
      #messages::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.3);
      }
      #messages::-webkit-scrollbar-thumb {
        background: rgba(100, 116, 139, 0.6);
        border-radius: 4px;
      }
      #messages::-webkit-scrollbar-thumb:hover {
        background: rgba(100, 116, 139, 0.8);
      }

      /* Modal and menu styles */
      .modal-overlay {
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
      }
      .modal-open {
        display: flex !important;
      }
      .modal-closed {
        display: none !important;
      }
      .menu-open {
        display: block !important;
      }
      .menu-closed {
        display: none !important;
      }

      /* Light mode styles */
      body.light-mode {
        background-color: #f8fafc;
        color: #1e293b;
      }

      body.light-mode .glass-card {
        background: rgba(248, 250, 252, 0.8);
        border-color: rgba(30, 41, 59, 0.15);
      }

      body.light-mode .glass-card:hover {
        border-color: rgba(30, 41, 59, 0.25);
      }

      body.light-mode #chatInterface .glass-card {
        background: rgba(248, 250, 252, 0.95);
        color: #1e293b;
      }

      body.light-mode #messages {
        background-color: #f1f5f9;
        color: #1e293b;
      }

      body.light-mode .message-bubble-anim:not(.mine) {
        background-color: #e2e8f0 !important;
        color: #1e293b !important;
        border-color: #cbd5e1 !important;
      }

      body.light-mode .message-bubble-anim.mine {
        background: linear-gradient(to bottom right, #0ea5e9, #0284c7) !important;
        color: white !important;
      }

      body.light-mode .text-slate-100,
      body.light-mode .text-slate-200,
      body.light-mode .text-slate-300 {
        color: #1e293b !important;
      }

      body.light-mode .text-slate-400 {
        color: #64748b !important;
      }

      body.light-mode .bg-slate-950,
      body.light-mode .bg-slate-900 {
        background-color: #f1f5f9 !important;
      }

      body.light-mode .bg-slate-800,
      body.light-mode .bg-slate-800\/80 {
        background-color: #e2e8f0 !important;
      }

      body.light-mode .bg-slate-700 {
        background-color: #cbd5e1 !important;
      }

      body.light-mode .bg-slate-700\/50 {
        background-color: rgba(203, 213, 225, 0.5) !important;
      }

      body.light-mode .hover\:bg-slate-700:hover,
      body.light-mode .hover\:bg-slate-600:hover {
        background-color: #cbd5e1 !important;
      }

      body.light-mode .border-slate-600\/60,
      body.light-mode .border-slate-700,
      body.light-mode .border-slate-800\/50 {
        border-color: #cbd5e1 !important;
      }

      body.light-mode input,
      body.light-mode textarea {
        background-color: #f1f5f9 !important;
        color: #1e293b !important;
        border-color: #cbd5e1 !important;
      }

      body.light-mode input::placeholder,
      body.light-mode textarea::placeholder {
        color: #94a3b8 !important;
      }

      body.light-mode input:focus,
      body.light-mode textarea:focus {
        border-color: #0ea5e9 !important;
      }

      body.light-mode .shadow-inner {
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1) !important;
      }

      body.light-mode #settingsMenu,
      body.light-mode #settingsModal,
      body.light-mode #profileModal {
        background: rgba(248, 250, 252, 0.95);
        border-color: rgba(30, 41, 59, 0.2);
      }

      body.light-mode .input-shell {
        background-color: #e2e8f0 !important;
        border-color: #cbd5e1 !important;
      }

      body.light-mode .input-shell:focus-within {
        border-color: #0ea5e9 !important;
      }

      /* Fast mode: trim effects for low-end devices */
      body.perf-lite * {
        animation: none !important;
        transition: none !important;
      }
      body.perf-lite .modal-overlay,
      body.perf-lite .message-bubble-anim:not(.mine) {
        backdrop-filter: none !important;
      }
      body.perf-lite .glass-card,
      body.perf-lite .message-bubble-anim {
        box-shadow: none !important;
      }

      /* Message size classes */
      .msg-small .message-bubble-anim {
        font-size: 0.65rem;
        padding: 0.4rem 0.6rem !important;
      }
      .msg-large .message-bubble-anim {
        font-size: 0.95rem;
        padding: 0.6rem 1rem !important;
      }

      /* Glass card style for panels (more subtle) */
      .glass-card {
        background: rgba(15, 23, 42, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.2);
        backdrop-filter: blur(8px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.2s ease;
      }
      .glass-card:hover {
        border-color: rgba(148, 163, 184, 0.3);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
      }

      /* Animated background blobs (much more subtle) */
      .bg-orb {
        position: fixed;
        border-radius: 9999px;
        filter: blur(80px);
        opacity: 0.08;
        pointer-events: none;
        z-index: -10;
      }
      .bg-orb-blue {
        background: radial-gradient(circle, rgba(56, 189, 248, 0.4), transparent 60%);
        animation: float-slow 20s ease-in-out infinite alternate;
      }
      .bg-orb-purple {
        background: radial-gradient(circle, rgba(129, 140, 248, 0.35), transparent 60%);
        animation: float-medium 24s ease-in-out infinite alternate;
      }
      .bg-orb-pink {
        background: radial-gradient(circle, rgba(236, 72, 153, 0.3), transparent 60%);
        animation: float-fast 26s ease-in-out infinite alternate;
      }

      @keyframes float-slow {
        0% {
          transform: translate3d(-10px, 0, 0) scale(1);
        }
        100% {
          transform: translate3d(20px, 30px, 0) scale(1.06);
        }
      }
      @keyframes float-medium {
        0% {
          transform: translate3d(10px, 20px, 0) scale(0.96);
        }
        100% {
          transform: translate3d(-20px, -10px, 0) scale(1.04);
        }
      }
      @keyframes float-fast {
        0% {
          transform: translate3d(-25px, 10px, 0) scale(1.03);
        }
        100% {
          transform: translate3d(15px, -25px, 0) scale(0.97);
        }
      }

      /* Message bubble animations - optimized for speed */
      @keyframes slide-up-fade {
        0% {
          opacity: 0;
          transform: translateY(8px) scale(0.95);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      
      @keyframes bounce-in {
        0% {
          opacity: 0;
          transform: scale(0.8) translateY(12px);
        }
        70% {
          opacity: 1;
          transform: scale(1.02);
        }
        100% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      @keyframes text-reveal {
        0% {
          opacity: 0;
          clip-path: inset(0 100% 0 0);
        }
        100% {
          opacity: 1;
          clip-path: inset(0 0 0 0);
        }
      }

      .message-bubble-anim {
        animation: slide-up-fade 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      .message-bubble-anim.mine {
        animation: bounce-in 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .message-text-reveal {
        animation: text-reveal 0.35s ease-out;
      }

      /* Subtle input styling */
      .input-shell {
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(148, 163, 184, 0.15);
        transition: all 0.2s ease;
      }
      .input-shell:focus-within {
        border-color: rgba(148, 163, 184, 0.3);
      }

      /* Subtle button styles */
      .btn-primary {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.15s ease;
      }
      .btn-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .btn-primary:active {
        transform: translateY(0);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
      }
    </style>
  </head>

  <body class="bg-slate-950 text-white h-screen min-h-screen flex flex-col relative overflow-hidden">
    <!-- Glowing background blobs -->
    <div class="bg-orb bg-orb-blue w-72 h-72 -top-20 -left-10"></div>
    <div class="bg-orb bg-orb-purple w-80 h-80 -bottom-32 -right-6"></div>
    <div class="bg-orb bg-orb-pink w-64 h-64 top-1/4 right-1/4"></div>

    <!-- Loading Screen -->
    <div
      id="loadingScreen"
      class="fixed inset-0 z-50 bg-slate-950 flex items-center justify-center"
    >
      <div class="flex flex-col items-center gap-6">
        <div class="relative w-20 h-20">
          <!-- Outer rotating ring -->
          <div class="absolute inset-0 rounded-full border-2 border-transparent border-t-sky-500 border-r-sky-400 animate-spin"></div>
          <!-- Middle rotating ring (opposite direction) -->
          <div class="absolute inset-2 rounded-full border-2 border-transparent border-b-indigo-500 border-l-indigo-400 animate-spin" style="animation-direction: reverse; animation-duration: 2s;"></div>
          <!-- Inner pulsing circle -->
          <div class="absolute inset-4 rounded-full bg-gradient-to-r from-sky-500 to-indigo-500 animate-pulse"></div>
        </div>
        <div class="text-center">
          <h2 class="text-xl font-semibold text-slate-100 mb-2">Loading your messages</h2>
          <p class="text-sm text-slate-400">Connecting to chat...</p>
        </div>
      </div>
    </div>

    <!-- Top bar / logo -->
    <header class="px-4 pt-4 pb-2 flex items-center justify-between z-10">
      <div class="flex items-center gap-3">
        <div
          class="h-9 w-9 rounded-lg bg-gradient-to-br from-blue-600 to-blue-800 flex items-center justify-center text-xl font-black relative shadow-lg shadow-blue-900/50 hover:shadow-blue-900/80 hover:from-blue-500 hover:to-blue-700 transition-all duration-200"
          title="Chatra Chat"
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <!-- Chat bubble with gradient -->
            <path d="M20 2H4C2.9 2 2 2.9 2 4V22L6 18H20C21.1 18 22 17.1 22 16V4C22 2.9 21.1 2 20 2Z" fill="white" opacity="0.95"/>
            <!-- Inner accent -->
            <circle cx="7" cy="10" r="1.5" fill="#1e40af" opacity="0.9"/>
            <circle cx="12" cy="10" r="1.5" fill="#1e40af" opacity="0.9"/>
            <circle cx="17" cy="10" r="1.5" fill="#1e40af" opacity="0.9"/>
          </svg>
        </div>
        <div class="flex flex-col">
          <h1 class="font-semibold text-lg text-slate-100">
            Chatra
          </h1>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button
          id="notifBellBtn"
          class="hidden relative px-3 py-2 rounded-full bg-slate-800/70 border border-slate-700/70 text-slate-200 hover:bg-slate-700/70 transition-colors"
          title="Notifications"
        >
          <span class="sr-only">Notifications</span>
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="inline align-middle">
            <path d="M18 8a6 6 0 1 0-12 0c0 7-3 9-3 9h18s-3-2-3-9"/>
            <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
          </svg>
          <span
            id="notifBellBadge"
            class="hidden absolute -top-1 -right-1 text-[10px] px-1.5 py-0.5 rounded-full bg-red-500 text-white font-semibold"
          >0</span>
        </button>
        <div
          class="hidden sm:flex items-center gap-2 px-3 py-1 rounded-full bg-slate-800/50 border border-slate-700/50 text-[11px] uppercase tracking-widest"
        >
          <span class="h-2 w-2 rounded-full bg-emerald-500"></span>
          <span class="text-slate-300">Online</span>
        </div>
      </div>
    </header>

    <!-- Login Form (visible by default) -->
    <div
      id="loginForm"
      class="flex-1 flex items-center justify-center pb-4 px-3 sm:px-4"
    >
      <div
        class="glass-card w-full max-w-md p-6 sm:p-8 rounded-2xl"
      >
        <div class="flex flex-col items-center mb-6">
          <h2 class="text-2xl font-semibold text-center mb-2">Welcome back</h2>
          <p class="text-sm text-slate-300 text-center">
            Log in to start chatting
          </p>
        </div>

        <!-- Username only -->
        <label class="block text-xs font-medium text-slate-300 mb-1 ml-1"
          >Username</label
        >
        <input
          id="loginUsername"
          type="text"
          placeholder="Your username"
          class="mb-4 p-3 rounded-xl w-full bg-slate-800/80 border border-slate-600/60 focus:border-sky-400 focus:ring-2 focus:ring-sky-500/60 outline-none transition-all shadow-inner shadow-slate-900/80"
          required
        />

        <!-- Password -->
        <label class="block text-xs font-medium text-slate-300 mb-1 ml-1"
          >Password</label
        >
        <input
          id="loginPassword"
          type="password"
          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          class="mb-3 p-3 rounded-xl w-full bg-slate-800/80 border border-slate-600/60 focus:border-sky-400 focus:ring-2 focus:ring-sky-500/60 outline-none transition-all shadow-inner shadow-slate-900/80"
          required
        />

        <!-- Remember me -->
        <label class="flex items-center gap-2 mb-3 text-xs text-gray-300">
          <input
            id="rememberMe"
            type="checkbox"
            class="h-4 w-4 rounded border-slate-500 bg-slate-800/90"
          />
          <span>Remember me on this device</span>
        </label>

        <!-- Error / info messages -->
        <p
          id="loginError"
          class="text-xs text-red-400 min-h-[1.25rem] mb-1"
        ></p>
        <p
          id="loginInfo"
          class="text-xs text-emerald-400 min-h-[1.25rem] mb-3"
        ></p>

        <button
          id="loginBtn"
          class="btn-primary w-full p-3 bg-sky-600 hover:bg-sky-700 rounded-lg font-medium transition-colors"
        >
          Login
        </button>

        <p class="mt-4 text-xs text-gray-300 text-center">
          Don't have an account?
          <a
            href="#"
            id="registerLink"
            class="text-sky-300 hover:text-sky-200 underline underline-offset-4"
            >Register here</a
          >
        </p>
      </div>
    </div>

    <!-- Registration Form (hidden by default) -->
    <div
      id="registerForm"
      class="flex-1 flex items-center justify-center pb-4 px-3 sm:px-4 hidden"
    >
      <div
        class="glass-card w-full max-w-md p-6 sm:p-8 rounded-2xl"
      >
        <div class="flex flex-col items-center mb-6">
          <h2 class="text-2xl font-semibold text-center mb-2">Create account</h2>
          <p class="text-sm text-slate-300 text-center">
            Pick a unique username
          </p>
        </div>

        <!-- Username -->
        <label class="block text-xs font-medium text-slate-300 mb-1 ml-1"
          >Username</label
        >
        <input
          id="regUsername"
          type="text"
          placeholder="CoolName"
          class="mb-3 p-3 rounded-xl w-full bg-slate-800/80 border border-slate-600/60 focus:border-sky-400 focus:ring-2 focus:ring-sky-500/60 outline-none transition-all shadow-inner shadow-slate-900/80"
          required
        />

        <!-- Password -->
        <label class="block text-xs font-medium text-slate-300 mb-1 ml-1"
          >Password</label
        >
        <input
          id="regPassword"
          type="password"
          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          class="mb-3 p-3 rounded-xl w-full bg-slate-800/80 border border-slate-600/60 focus:border-sky-400 focus:ring-2 focus:ring-sky-500/60 outline-none transition-all shadow-inner shadow-slate-900/80"
          required
        />

        <!-- Confirm Password -->
        <label class="block text-xs font-medium text-slate-300 mb-1 ml-1"
          >Confirm Password</label
        >
        <input
          id="regPasswordConfirm"
          type="password"
          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          class="mb-3 p-3 rounded-xl w-full bg-slate-800/80 border border-slate-600/60 focus:border-sky-400 focus:ring-2 focus:ring-sky-500/60 outline-none transition-all shadow-inner shadow-slate-900/80"
          required
        />

        <!-- Error / info messages -->
        <p
          id="registerError"
          class="text-xs text-red-400 min-h-[1.25rem] mb-3"
        ></p>

        <button
          id="registerBtn"
          class="btn-primary w-full p-3 bg-sky-600 hover:bg-sky-700 rounded-lg font-medium transition-colors"
        >
          Register
        </button>

        <!-- Terms and Privacy Policy -->
        <p class="mt-4 text-xs text-gray-300 text-center">
          By signing up you agree to our
          <button
            type="button"
            id="termsLink"
            onclick="document.getElementById('termsModal').classList.remove('modal-closed');document.getElementById('termsModal').classList.add('modal-open');"
            class="font-bold text-sky-300 hover:text-sky-200 underline underline-offset-4 bg-none border-none cursor-pointer"
          >
            Terms of Service
          </button>
          and
          <button
            type="button"
            id="privacyLink"
            onclick="document.getElementById('privacyModal').classList.remove('modal-closed');document.getElementById('privacyModal').classList.add('modal-open');"
            class="font-bold text-sky-300 hover:text-sky-200 underline underline-offset-4 bg-none border-none cursor-pointer"
          >
            Privacy Policy
          </button>
        </p>

        <p class="mt-3 text-xs text-gray-300 text-center">
          Already have an account?
          <a
            href="#"
            id="loginLink"
            class="text-sky-300 hover:text-sky-200 underline underline-offset-4"
            >Login here</a
          >
        </p>
      </div>
    </div>

    <!-- Terms of Service Modal (global) -->
    <div
      id="termsModal"
      class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
    >
      <div class="glass-card max-w-2xl w-full rounded-2xl p-6 sm:p-8 max-h-[90vh] overflow-y-auto">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-2xl font-semibold text-slate-100">Terms of Service</h3>
          <button
            id="termsCloseBtn"
            onclick="document.getElementById('termsModal').classList.add('modal-closed');document.getElementById('termsModal').classList.remove('modal-open');"
            class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
          >
            ‚úï
          </button>
        </div>

        <!-- Terms content - EDIT THIS SECTION WITH YOUR OWN TERMS -->
<div id="termsContent" class="text-sm text-slate-300 space-y-3 leading-relaxed">
  <p>
    <strong>Last Updated:</strong> December 7, 2025
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">1. Acceptance of Terms</h4>
  <p>
    By creating an account and using Chatra, you agree to comply with these Terms of Service.
    If you do not agree to these terms, please do not use our service.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">2. User Accounts</h4>
  <p>
    You are responsible for maintaining the confidentiality of your account password and for all activities
    that occur under your account. You agree to provide accurate information when creating an account.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">3. User Conduct</h4>
  <p>
    You agree not to use Chatra for any unlawful purpose or in any way that violates these Terms.
    This includes but is not limited to: harassment, hate speech, spam, or sharing inappropriate content.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">4. Content</h4>
  <p>
    You retain all rights to any content you post on Chatra. By posting content, you grant Chatra
    a license to display and store that content to provide our services.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">5. Limitation of Liability</h4>
  <p>
    Chatra is provided "as is" without warranties of any kind. We are not liable for any indirect,
    incidental, special, or consequential damages resulting from your use of the service.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">6. Changes to Terms</h4>
  <p>
    We reserve the right to modify these Terms of Service at any time. Continued use of Chatra
    after changes constitute your acceptance of the new Terms.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">7. Acceptable Use Policy (AUP)</h4>
  <p>
    To keep Chatra safe for everyone, you agree not to use the Service to:
  </p>

  <h5 class="font-semibold text-slate-200 mt-4">Safety & Respect</h5>
  <p>
    - Harass, threaten, bully, or encourage harm,  
    - Post hate speech, racism, slurs, or discrimination,  
    - Target or attack people based on gender, identity, nationality, religion, disability, or similar traits.
  </p>

  <h5 class="font-semibold text-slate-200 mt-4">Content Rules</h5>
  <p>
    - Share pornography, sexual content, nudity, or graphic violence,  
    - Post extremely disturbing or dangerous content,  
    - Upload copyrighted content you do not own,  
    - Spread false information that could harm others.
  </p>

  <h5 class="font-semibold text-slate-200 mt-4">Security & Misuse</h5>
  <p>
    - Spread malware, scams, or harmful links,  
    - Attempt to hack, overload, abuse, or reverse-engineer the Service,  
    - Use bots, exploits, or automate features without permission,  
    - Manipulate or break security or moderation systems.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">8. Privacy and Safety</h4>
  <p>
    Chatra stores limited information ‚Äî such as usernames, messages, and timestamps ‚Äî to provide chat features.
    Private chats and DMs are visible only to people in the conversation.
    However, authorized administrators may review stored content for moderation, safety checks, legal requests, or technical fixes.
    For details on how your data is handled, please read our Privacy Policy.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">9. Moderation</h4>
  <p>
    We reserve the right to:
    - Remove or edit messages, usernames, or other content,  
    - Temporarily or permanently ban users,  
    - Limit or disable features that are being abused.
    These actions may be taken without prior notice to protect users and maintain a safe environment.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">10. Service Availability</h4>
  <p>
    Chatra is provided ‚Äúas is.‚Äù  
    While we try to keep the Service running smoothly, we cannot guarantee:
    - The Service will always be online or error-free,  
    - That all messages or data will always send or save correctly,  
    - That downtime or bugs will never happen.  
    We are not responsible for losses or issues caused by outages, errors, or misuse.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">11. DMCA / Copyright Policy</h4>
  <p>
    Chatra respects copyright laws, including the Digital Millennium Copyright Act (DMCA).  
    If you believe something on Chatra uses your copyrighted work without permission, you may send a DMCA takedown request. We will review the request and remove the content if required.
  </p>
  <p>
    A valid DMCA request must include:
    - Your name and contact information,  
    - A description of the copyrighted work,  
    - A link or description of where the content appears on Chatra,  
    - A statement explaining you believe the use is not authorized,  
    - A statement that the information in your request is true,  
    - Your signature (typed name is okay).
  </p>
  <p>
    Send DMCA requests to:  
    üìß **chatrahelpcenter@gmail.com**
  </p>
  <p>
    If your content is removed and you believe this was a mistake, you may send a counter-notice explaining why the content is permitted.  
    We may disable accounts that repeatedly violate copyright laws.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">12. Changes to These Terms</h4>
  <p>
    We may update these Terms from time to time to improve clarity or follow new laws.  
    When we do, we will update the ‚ÄúLast updated‚Äù date above.  
    If you continue using Chatra after updates, that means you accept the new Terms.
  </p>

  <h4 class="font-semibold text-slate-200 mt-4">13. Contact Us</h4>
  <p>
    If you have questions, need help, or want to report a problem, contact us at:  
    üìß **chatrahelpcenter@gmail.com**
  </p>

</div>


        <button
          id="termsCloseBtn2"
          onclick="document.getElementById('termsModal').classList.add('modal-closed');document.getElementById('termsModal').classList.remove('modal-open');"
          class="w-full mt-6 px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 transition-colors font-medium text-slate-100"
        >
          Close
        </button>
      </div>
    </div>

    <!-- Privacy Policy Modal (global) -->
    <div
      id="privacyModal"
      class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
    >
      <div class="glass-card max-w-2xl w-full rounded-2xl p-6 sm:p-8 max-h-[90vh] overflow-y-auto">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-2xl font-semibold text-slate-100">Privacy Policy</h3>
          <button
            id="privacyCloseBtn"
            onclick="document.getElementById('privacyModal').classList.add('modal-closed');document.getElementById('privacyModal').classList.remove('modal-open');"
            class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
          >
            ‚úï
          </button>
        </div>

        <!-- Privacy content - EDIT THIS SECTION WITH YOUR OWN PRIVACY POLICY -->
        <div id="privacyContent" class="text-sm text-slate-300 space-y-3 leading-relaxed">
          <p>
            <strong>Last Updated:</strong> December 6, 2025
          </p>

          <h4 class="font-semibold text-slate-200 mt-4">1. Information We Collect</h4>
          <p>
            We collect the information you provide directly, such as your username and password when you create an account.
            We also collect information about your interactions with our service, including messages and account settings.
          </p>

          <h4 class="font-semibold text-slate-200 mt-4">1.1 Account Information</h4>
          <p>When you create an account, we collect:</p>
          <ul class="list-disc pl-5 space-y-1">
            <li>Username</li>
            <li>Password (stored securely and never visible to us)</li>
          </ul>
          <p>We do not require your real name, phone number, or email.</p>

          <h4 class="font-semibold text-slate-200 mt-4">1.2 Messages</h4>
          <p>Chatra stores:</p>
          <ul class="list-disc pl-5 space-y-1">
            <li>Messages you send</li>
            <li>Timestamps</li>
            <li>Sender and recipient information</li>
            <li>Group chat participation</li>
          </ul>
          <p>
            Messages are not end-to-end encrypted, which means we can technically access them if needed for safety or moderation.
            We never sell or share your messages with advertisers.
          </p>

          <h4 class="font-semibold text-slate-200 mt-4">1.3 Usage Information</h4>
          <p>We may collect basic technical data such as:</p>
          <ul class="list-disc pl-5 space-y-1">
            <li>Device type</li>
            <li>Browser information</li>
            <li>IP address</li>
            <li>App performance and crash data</li>
          </ul>
          <p>This helps us keep Chatra running smoothly.</p>

          <h4 class="font-semibold text-slate-200 mt-4">2. How We Use Your Information</h4>
          <p>We use your information to:</p>
          <ul class="list-disc pl-5 space-y-1">
            <li>Provide chat features (messages, DMs, group chats)</li>
            <li>Keep the Service safe and functioning properly</li>
            <li>Prevent spam, abuse, and violations of our Terms</li>
            <li>Fix bugs and improve performance</li>
          </ul>
          <p>We do not sell your information or use it for targeted advertising.</p>

          <h4 class="font-semibold text-slate-200 mt-4">3. Who Can See Your Information?</h4>

          <h5 class="font-semibold text-slate-200 mt-4">3.1 Other Users</h5>
          <ul class="list-disc pl-5 space-y-1">
            <li>Messages in public or group chats are visible to everyone in that chat.</li>
            <li>Direct Messages (DMs) are visible only to the people in the conversation.</li>
          </ul>

          <h5 class="font-semibold text-slate-200 mt-4">3.2 Administrators</h5>
          <p>Authorized administrators may access stored data only when necessary, such as:</p>
          <ul class="list-disc pl-5 space-y-1">
            <li>Investigating abuse, threats, or unsafe behavior</li>
            <li>Handling reports or fixing technical issues</li>
            <li>Enforcing the Terms of Service</li>
            <li>Complying with legal requirements</li>
          </ul>

          <h5 class="font-semibold text-slate-200 mt-4">3.3 Third Parties</h5>
          <p>
            We do not sell, rent, or trade your data with third parties.
            We may use trusted services (such as Firebase) to store data securely.
          </p>

          <h4 class="font-semibold text-slate-200 mt-4">4. Data Safety</h4>
          <p>We take reasonable steps to protect your information, including:</p>
          <ul class="list-disc pl-5 space-y-1">
            <li>Secure password storage</li>
            <li>Database rules that restrict access</li>
            <li>Monitoring for abuse or attacks</li>
            <li>Regular system updates</li>
          </ul>
          <p>However, no online service is 100% secure, and we cannot guarantee absolute protection.</p>

          <h4 class="font-semibold text-slate-200 mt-4">5. Your Choices and Controls</h4>
          <p>You may:</p>
          <ul class="list-disc pl-5 space-y-1">
            <li>Change your username or account information</li>
            <li>Request message deletion</li>
            <li>Request account deletion</li>
            <li>Stop using Chatra at any time</li>
          </ul>
          <p>
            Deleting your account permanently removes your username and profile data.
            Some message logs may be kept temporarily for safety or legal reasons.
          </p>

          <h4 class="font-semibold text-slate-200 mt-4">6. Children‚Äôs Privacy</h4>
          <p>
            Chatra is for users <strong>13 years or older</strong>.
            We do not knowingly collect data from children under 13.
            If we learn a user under 13 has created an account, we will remove it.
          </p>

          <h4 class="font-semibold text-slate-200 mt-4">7. Changes to This Policy</h4>
          <p>
            We may update this Privacy Policy from time to time.
            When we do, we will update the ‚ÄúLast updated‚Äù date above.
            If you continue using Chatra after changes, you accept the updated Policy.
          </p>

          <h4 class="font-semibold text-slate-200 mt-4">8. Contact Us</h4>
          <p>
            If you have questions or need help with your data, contact us at:
            üìß <strong>chatrahelpcenter@gmail.com</strong>
          </p>
        </div>


        <button
          id="privacyCloseBtn2"
          onclick="document.getElementById('privacyModal').classList.add('modal-closed');document.getElementById('privacyModal').classList.remove('modal-open');"
          class="w-full mt-6 px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 transition-colors font-medium text-slate-100"
        >
          Close
        </button>
      </div>
    </div>

    <!-- Chat Interface (hidden by default) -->
    <div
      id="chatInterface"
      class="hidden flex-1 min-h-0 flex flex-col"
    >
      <!-- FULLSCREEN chat container -->
      <div
        class="glass-card flex-1 min-h-0 flex flex-col w-full rounded-none overflow-hidden"
      >
        <!-- Chat header with menu + logout -->
        <div
          class="relative flex items-center justify-between px-4 sm:px-5 py-3 bg-slate-900/70 border-b border-slate-800/50"
        >
          <div class="flex items-center gap-3">
            <!-- Hamburger Menu Button -->
            <button
              id="menuToggle"
              class="p-1.5 hover:bg-slate-700 rounded-lg transition-colors"
              title="Menu"
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-300">
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
              </svg>
            </button>
            <span
              id="chatUserLabel"
              class="text-sm text-slate-200 font-medium"
            ></span>
          </div>
          
          <!-- Global Chat in Middle -->
          <div class="absolute left-1/2 transform -translate-x-1/2 flex items-center gap-2">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-blue-400">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="2" y1="12" x2="22" y2="12"></line>
              <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
            </svg>
            <span class="text-sm font-bold text-slate-100">Global Chat</span>
          </div>
          
          <button
            id="logoutBtn"
            class="px-3 py-1.5 text-xs rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors"
          >
            Logout
          </button>
        </div>

        <!-- Settings Modal -->
        <div
          id="settingsModal"
          class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
        >
          <div class="glass-card max-w-md w-full rounded-2xl p-6 max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-lg font-semibold text-slate-100">Settings</h3>
              <button
                id="settingsCloseBtn"
                class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
              >
                ‚úï
              </button>
            </div>

            <!-- Message Size Control -->
            <div class="mb-5 pb-5 border-b border-slate-700">
              <label class="text-sm font-medium text-slate-200 block mb-2">Message Size</label>
              <div class="flex gap-2">
                <button
                  data-size="small"
                  class="size-btn flex-1 px-3 py-2 rounded-lg text-xs font-medium transition-colors bg-slate-700 hover:bg-slate-600 text-slate-200"
                >
                  Small
                </button>
                <button
                  data-size="medium"
                  class="size-btn flex-1 px-3 py-2 rounded-lg text-xs font-medium transition-colors bg-sky-600 hover:bg-sky-700 text-white active"
                >
                  Medium
                </button>
                <button
                  data-size="large"
                  class="size-btn flex-1 px-3 py-2 rounded-lg text-xs font-medium transition-colors bg-slate-700 hover:bg-slate-600 text-slate-200"
                >
                  Large
                </button>
              </div>
            </div>

            <!-- Theme Control -->
            <div class="mb-5 pb-5 border-b border-slate-700">
              <label class="text-sm font-medium text-slate-200 block mb-2">Theme</label>
              <div class="flex gap-2">
                <button
                  data-theme="dark"
                  class="theme-btn flex-1 px-3 py-2 rounded-lg text-xs font-medium transition-colors bg-sky-600 hover:bg-sky-700 text-white active flex items-center justify-center gap-1"
                >
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
                  Dark
                </button>
                <button
                  data-theme="light"
                  class="theme-btn flex-1 px-3 py-2 rounded-lg text-xs font-medium transition-colors bg-slate-700 hover:bg-slate-600 text-slate-200 flex items-center justify-center gap-1"
                >
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
                  Light
                </button>
              </div>
            </div>

            <!-- Fast Mode Toggle -->
            <div class="mb-5 pb-5 border-b border-slate-700 flex items-center justify-between">
              <div>
                <label id="fastModeLabel" class="text-sm font-medium text-slate-200 block mb-1">Fast Mode</label>
                <p class="text-xs text-slate-400">Limits message load to 50 and reduces effects.</p>
              </div>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="fastModeToggle" class="sr-only peer">
                <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:bg-sky-600 transition-colors"></div>
                <span class="absolute left-1 top-1 w-4 h-4 bg-white rounded-full transition-transform peer-checked:translate-x-5"></span>
              </label>
            </div>

            <div class="text-xs text-slate-400 text-center">
              <p>Chatra v1.0</p>
            </div>
          </div>
        </div>

        <!-- User Profile Modal -->
        <div
          id="profileModal"
          class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
        >
          <div class="glass-card max-w-sm w-full rounded-2xl p-6 max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-lg font-semibold text-slate-100">My Profile</h3>
              <button
                id="profileCloseBtn"
                class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
              >
                ‚úï
              </button>
            </div>

            <!-- Profile Picture -->
            <div class="mb-5 flex flex-col items-center">
              <div
                id="profilePicPreview"
                class="h-20 w-20 rounded-full bg-gradient-to-br from-sky-500 to-sky-600 flex items-center justify-center text-white text-2xl font-bold mb-2 shadow-lg"
              >
                <svg width="40" height="40" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
              </div>
              <input
                id="profilePicInput"
                type="file"
                accept="image/*"
                class="hidden"
              />
              <button
                id="uploadPicBtn"
                class="px-3 py-1.5 text-xs rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors"
              >
                Upload Photo
              </button>
            </div>

            <!-- Username Input (Editable) -->
            <div class="mb-4">
              <label class="text-xs font-medium text-slate-300 block mb-1">Username</label>
              <input
                id="profileUsername"
                type="text"
                placeholder="Your username"
                class="w-full p-2 rounded-lg bg-slate-800/80 border border-slate-600/60 focus:border-sky-400 focus:ring-2 focus:ring-sky-500/60 outline-none transition-all text-sm text-slate-100 placeholder-slate-500"
              />
            </div>

            <!-- Bio -->
            <div class="mb-4">
              <label class="text-xs font-medium text-slate-300 block mb-1">Bio (max 150 chars)</label>
              <textarea
                id="profileBio"
                placeholder="Tell us about yourself..."
                maxlength="150"
                class="w-full p-2 rounded-lg bg-slate-800/80 border border-slate-600/60 focus:border-sky-400 focus:ring-2 focus:ring-sky-500/60 outline-none transition-all text-sm text-slate-100 placeholder-slate-500 resize-none"
                rows="3"
              ></textarea>
            </div>

            <!-- Save Button -->
            <button
              id="saveProfileBtn"
              class="w-full px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 transition-colors font-medium text-sm text-white"
            >
              Save Profile
            </button>
          </div>
        </div>

        <!-- View User Profile Modal (Read-Only) -->
        <div
          id="viewProfileModal"
          class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
        >
          <div class="glass-card max-w-sm w-full rounded-3xl p-8 max-h-[90vh] overflow-y-auto text-center">
            <!-- Close Button -->
            <button
              id="viewProfileCloseBtn"
              class="absolute top-4 right-4 p-1 hover:bg-slate-700 rounded-lg transition-colors"
            >
              ‚úï
            </button>

            <!-- Large Profile Picture -->
            <div
              id="viewProfilePic"
              class="h-32 w-32 rounded-full bg-gradient-to-br from-sky-500 to-sky-600 flex items-center justify-center text-white text-5xl font-bold mb-6 shadow-lg mx-auto"
            >
              <svg width="64" height="64" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
            </div>

            <!-- Username -->
            <h2 id="viewProfileName" class="text-2xl font-bold text-slate-100 mb-2">
              Username
            </h2>

            <!-- Bio -->
            <p id="viewProfileBio" class="text-sm text-slate-300 mb-6 leading-relaxed">
              No bio yet
            </p>

            <!-- Friend Request Button -->
            <button
              id="sendFriendRequestBtn"
              class="w-full px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 transition-colors font-medium text-sm text-white mb-2"
            >
              Add Friend
            </button>

            <!-- Block Button -->
            <button
              id="blockUserBtn"
              class="w-full px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 transition-colors font-medium text-sm text-white mb-2 flex items-center justify-center gap-2"
            >
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/>
              </svg>
              Block User
            </button>

            <div
              id="friendRequestStatus"
              class="hidden text-xs text-slate-200 bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 mb-3 text-left"
              role="status"
            ></div>

            <!-- Admin Actions (visible only to admins) -->
            <div
              id="profileAdminActions"
              class="hidden flex gap-2 mb-3"
            >
              <button
                id="profileBanBtn"
                class="flex-1 px-3 py-2 rounded-lg bg-red-600 hover:bg-red-700 transition-colors font-medium text-xs text-white"
              >
                Ban
              </button>
              <button
                id="profileMuteBtn"
                class="flex-1 px-3 py-2 rounded-lg bg-yellow-600 hover:bg-yellow-700 transition-colors font-medium text-xs text-white"
              >
                Mute
              </button>
              <button
                id="profileWarnBtn"
                class="flex-1 px-3 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 transition-colors font-medium text-xs text-white"
              >
                Warn
              </button>
            </div>

            <!-- Close Button (Bottom) -->
            <button
              id="viewProfileCloseBtn2"
              class="w-full px-4 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors font-medium text-sm text-slate-100"
            >
              Close
            </button>
          </div>
        </div>

        <!-- Chat Messages -->
        <div
          id="messages"
          class="flex-1 min-h-0 overflow-y-auto px-2 sm:px-3 py-2 sm:py-3 space-y-1 bg-slate-900"
        ></div>

        <!-- Combined status bar (typing + warnings) -->
        <div
          class="px-4 py-1.5 text-xs bg-slate-800 border-t border-slate-700 flex items-center gap-2 text-slate-300"
        >
          <span
            class="h-1.5 w-1.5 rounded-full bg-emerald-500"
          ></span>
          <p
            id="typingIndicator"
            class="flex-1 min-h-[0.5rem]"
            style="padding: 0; margin: 0;"
          ></p>
          <!-- Old warning element kept but visually empty (text controlled in JS) -->
          <p
            id="sendWarning"
            class="hidden text-sm text-red-400 min-h-[0.5rem]"
          ></p>
        </div>

        <!-- Media Preview -->
        <div id="mediaPreview" class="hidden p-3 bg-slate-800 border-t border-slate-700">
          <div class="flex items-start gap-3">
            <div id="mediaPreviewContent" class="flex-1"></div>
            <button
              type="button"
              id="cancelMediaBtn"
              class="p-1 hover:bg-slate-700 rounded-lg transition-colors text-slate-400"
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        </div>

        <!-- Message Input (wrapped in a form so Enter submits on any device) -->
        <form
          id="messageForm"
          class="p-2 sm:p-3 bg-slate-900 border-t border-slate-800 w-full"
        >
          <div
            id="muteInlineBanner"
            class="hidden mb-2 rounded-lg border border-blue-600 bg-slate-800 text-slate-100 px-3 py-2 text-sm flex items-center justify-between gap-2"
          >
            <span id="muteInlineText"></span>
          </div>
          <div
            class="input-shell flex items-center gap-1.5 sm:gap-2 bg-slate-800 rounded-lg px-2 sm:px-3 py-1.5 sm:py-2"
          >
            <input type="file" id="imageInput" accept="image/*,video/*" class="hidden" />
            <button
              type="button"
              id="mediaUploadBtn"
              class="p-2 hover:bg-slate-700 rounded-lg transition-colors"
              title="Upload image or video"
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-400">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21 15 16 10 5 21"/>
              </svg>
            </button>
            <input
              id="msgInput"
              class="flex-1 px-3 py-2.5 rounded-lg bg-transparent text-sm sm:text-base placeholder:text-slate-500 focus:outline-none focus:ring-0"
              placeholder="Type a message..."
              autocomplete="off"
            />
            <button
              id="sendBtn"
              type="submit"
              class="btn-primary flex items-center gap-2 px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 text-sm sm:text-[15px] font-medium transition-colors"
            >
              <span>Send</span>
              <span class="text-lg leading-none">‚û§</span>
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Warn Reason Modal -->
    <div
      id="warnReasonModal"
      class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center hidden"
    >
      <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-96 shadow-2xl">
        <h2 class="text-xl font-bold text-yellow-400 mb-4">Issue a Warning</h2>
        <p class="text-slate-300 mb-4">Select a reason or type a custom one:</p>
        
        <div class="space-y-2 mb-4">
          <button id="warnReasonSpam" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üì® Spam</button>
          <button id="warnReasonAbuse" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üò† Abusive Language</button>
          <button id="warnReasonDisruption" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üí¢ Disruption</button>
          <button id="warnReasonHarassment" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üö® Harassment</button>
        </div>

        <div class="mb-4">
          <input
            id="warnReasonCustom"
            type="text"
            placeholder="Or type a custom reason..."
            class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-slate-100 placeholder-slate-500"
          />
        </div>

        <div class="flex gap-2">
          <button
            id="warnReasonConfirm"
            class="flex-1 bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded-md text-white font-semibold"
          >
            Issue Warning
          </button>
          <button
            id="warnReasonCancel"
            class="flex-1 bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded-md text-slate-200"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Mute Reason Modal -->
    <div
      id="muteReasonModal"
      class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center hidden"
    >
      <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-96 shadow-2xl">
        <h2 class="text-xl font-bold text-blue-400 mb-4">Mute User</h2>
        <p class="text-slate-300 mb-4">Select a reason and duration:</p>
        
        <div class="space-y-2 mb-4">
          <button id="muteReasonSpam" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üì® Spam</button>
          <button id="muteReasonAbuse" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üò† Abusive Language</button>
          <button id="muteReasonDisruption" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üí¢ Disruption</button>
          <button id="muteReasonHarassment" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üö® Harassment</button>
        </div>

        <div class="mb-4">
          <input
            id="muteReasonCustom"
            type="text"
            placeholder="Or type a custom reason..."
            class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-slate-100 placeholder-slate-500 mb-3"
          />
          <label class="block text-sm text-slate-300 mb-2">Duration (minutes):</label>
          <input
            id="muteDuration"
            type="number"
            placeholder="10"
            min="1"
            max="10080"
            value="10"
            class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-slate-100"
          />
        </div>

        <div class="flex gap-2">
          <button
            id="muteReasonConfirm"
            class="flex-1 bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-md text-white font-semibold"
          >
            Mute User
          </button>
          <button
            id="muteReasonCancel"
            class="flex-1 bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded-md text-slate-200"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Ban Reason Modal -->
    <div
      id="banReasonModal"
      class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center hidden"
    >
      <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-96 shadow-2xl">
        <h2 class="text-xl font-bold text-red-500 mb-4">Ban User</h2>
        <p class="text-slate-300 mb-4">Select a reason and duration:</p>
        
        <div class="space-y-2 mb-4">
          <button id="banReasonSpam" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üì® Spam</button>
          <button id="banReasonAbuse" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üò† Abusive Language</button>
          <button id="banReasonDisruption" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üí¢ Disruption</button>
          <button id="banReasonHarassment" class="w-full text-left bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded text-slate-200">üö® Harassment</button>
        </div>

        <div class="mb-4">
          <input
            id="banReasonCustom"
            type="text"
            placeholder="Or type a custom reason..."
            class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-slate-100 placeholder-slate-500 mb-3"
          />
          <label class="block text-sm text-slate-300 mb-2">Duration:</label>
          <select
            id="banDuration"
            class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-slate-100"
          >
            <option value="60">1 hour</option>
            <option value="1440">1 day</option>
            <option value="10080">1 week</option>
            <option value="43200">1 month</option>
            <option value="permanent">üîí Permanent (delete account)</option>
          </select>
        </div>

        <div class="flex gap-2">
          <button
            id="banReasonConfirm"
            class="flex-1 bg-red-600 hover:bg-red-700 px-4 py-2 rounded-md text-white font-semibold"
          >
            Ban User
          </button>
          <button
            id="banReasonCancel"
            class="flex-1 bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded-md text-slate-200"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Warning Popup -->
    <div
      id="warningPopup"
      class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center hidden"
    >
      <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-80 text-center shadow-2xl">
        <h2 class="text-xl font-bold text-red-400 mb-3">You Have Been Warned</h2>
        <p id="warningReason" class="mb-4 text-slate-200"></p>

        <label class="flex items-center space-x-2 justify-center mb-4 select-none">
          <input type="checkbox" id="warningAgree" class="accent-red-500" />
          <span class="text-sm text-slate-300">I understand and agree</span>
        </label>

        <button
          id="closeWarningBtn"
          class="bg-red-500 px-4 py-2 rounded-md opacity-50 cursor-not-allowed text-white w-full"
          disabled
        >
          Close
        </button>
      </div>
    </div>

    <!-- Mute Popup -->
    <div
      id="mutePopup"
      class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center hidden"
    >
      <div class="bg-slate-900 border border-blue-500 p-6 rounded-xl w-80 text-center shadow-2xl">
        <p class="text-blue-400 font-bold mb-3 text-lg">You are muted</p>
        <p id="muteReason" class="text-slate-200 mb-4"></p>
        <p id="muteTimer" class="text-slate-300 text-sm font-semibold"></p>
      </div>
    </div>

    <!-- Ban Popup -->
    <div
      id="banPopup"
      class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center hidden"
    >
      <div class="bg-slate-900 border border-red-600 p-6 rounded-xl w-80 text-center shadow-2xl">
        <p class="text-red-500 font-bold mb-3 text-lg">You have been banned</p>
        <p id="banReason" class="text-slate-200 mb-4"></p>
        <p class="text-slate-400 text-sm">You will be logged out in 3 seconds...</p>
      </div>
    </div>

    <!-- Friend Requests Modal -->
    <div
      id="friendRequestsModal"
      class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
    >
      <div class="glass-card max-w-md w-full rounded-2xl p-6 max-h-[90vh] overflow-y-auto">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-semibold text-slate-100">Friend Requests</h3>
          <button
            id="friendRequestsCloseBtn"
            class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
          >
            ‚úï
          </button>
        </div>

        <div id="friendRequestsList" class="space-y-2">
          <!-- Friend requests will be rendered here -->
        </div>

        <p id="noFriendRequestsMsg" class="text-center text-slate-400 text-sm mt-4">
          No pending requests
        </p>
      </div>
    </div>

    <!-- Friends List Modal -->
    <div
      id="friendsListModal"
      class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
    >
      <div class="glass-card max-w-md w-full rounded-2xl p-6 max-h-[90vh] overflow-y-auto">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-semibold text-slate-100">Friends</h3>
          <button
            id="friendsListCloseBtn"
            class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
          >
            ‚úï
          </button>
        </div>

        <!-- Search Users -->
        <div class="mb-4">
          <input
            id="searchUsersInput"
            type="text"
            placeholder="Search users..."
            class="w-full px-4 py-2 bg-slate-700 text-slate-100 rounded-lg placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-sky-600"
          />
          <div id="searchResults" class="mt-2 space-y-2 max-h-60 overflow-y-auto">
            <!-- Search results will appear here -->
          </div>
        </div>

        <!-- Friends List -->
        <div class="border-t border-slate-700 pt-4">
          <h4 class="text-sm font-semibold text-slate-400 uppercase tracking-wider mb-2">Your Friends</h4>
          <div id="friendsList" class="space-y-2">
            <!-- Friends will be rendered here -->
          </div>

          <p id="noFriendsMsg" class="text-center text-slate-400 text-sm mt-4">
            No friends yet
          </p>
        </div>
      </div>
    </div>

    <!-- Blocked Users Modal -->
    <div
      id="blockedUsersModal"
      class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
    >
      <div class="glass-card max-w-md w-full rounded-2xl p-6 max-h-[90vh] overflow-y-auto">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-semibold text-slate-100">Blocked Users</h3>
          <button
            id="blockedUsersCloseBtn"
            class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
          >
            ‚úï
          </button>
        </div>

        <div id="blockedUsersList" class="space-y-2">
          <!-- Blocked users will be rendered here -->
        </div>

        <p id="noBlockedUsersMsg" class="text-center text-slate-400 text-sm mt-4">
          No blocked users
        </p>
      </div>
    </div>

    <!-- Image Viewer Modal -->
    <div
      id="imageViewerModal"
      class="fixed inset-0 z-50 hidden items-center justify-center bg-black/90 backdrop-blur-sm"
      style="cursor: zoom-out;"
    >
      <button
        id="closeImageViewer"
        class="absolute top-4 right-4 p-2 text-white hover:bg-white/10 rounded-lg transition-colors z-10"
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <img
        id="imageViewerImg"
        class="max-w-[95vw] max-h-[95vh] object-contain"
        style="cursor: zoom-out;"
      />
    </div>

    <!-- Side Panel -->
    <div
      id="sidePanel"
      class="fixed top-0 left-0 h-full w-72 glass-card z-50 flex flex-col transition-transform duration-300"
      style="transform: translateX(-100%);"
    >
      <!-- Side Panel Header -->
      <div class="flex justify-between items-center p-4 border-b border-slate-700/50">
        <div>
          <h3 class="text-lg font-semibold text-slate-100">Menu</h3>
          <p id="sidePanelUsername" class="text-xs text-slate-400"></p>
        </div>
        <button
          id="sidePanelClose"
          class="p-1.5 hover:bg-slate-700 rounded-lg transition-colors"
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>

      <!-- Side Panel Content -->
      <div class="flex-1 overflow-y-auto p-4 space-y-6">
        <!-- Profile Section -->
        <div>
          <h4 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2">Profile</h4>
          <div class="space-y-1">
            <button
              id="sidePanelProfile"
              class="w-full px-4 py-2.5 text-left text-sm text-slate-100 hover:bg-slate-700/50 rounded-lg transition-colors flex items-center gap-3"
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" class="text-slate-300">
                <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
              </svg>
              My Profile
            </button>
            <button
              id="sidePanelSettings"
              class="w-full px-4 py-2.5 text-left text-sm text-slate-100 hover:bg-slate-700/50 rounded-lg transition-colors flex items-center gap-3"
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-300">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v10M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m10 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"/>
              </svg>
              Settings
            </button>
            <button
              id="sidePanelPrivacy"
              class="w-full px-4 py-2.5 text-left text-sm text-slate-100 hover:bg-slate-700/50 rounded-lg transition-colors flex items-center gap-3"
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-300">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
              </svg>
              Privacy Settings
            </button>
          </div>
        </div>

        <!-- Social Section -->
        <div>
          <h4 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2">Social</h4>
          <div class="space-y-1">
            <button
              id="sidePanelFriendRequests"
              class="w-full px-4 py-2.5 text-left text-sm text-slate-100 hover:bg-slate-700/50 rounded-lg transition-colors flex items-center gap-3 relative"
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-300">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                <circle cx="9" cy="7" r="4"/>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
              </svg>
              Friend Requests
              <span id="sidePanelFriendBadge" class="ml-auto bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center hidden">0</span>
            </button>
            <button
              id="sidePanelFriends"
              class="w-full px-4 py-2.5 text-left text-sm text-slate-100 hover:bg-slate-700/50 rounded-lg transition-colors flex items-center gap-3"
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" class="text-slate-300">
                <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
              </svg>
              Friends
            </button>
            <button
              id="sidePanelDMs"
              class="w-full px-4 py-2.5 text-left text-sm text-slate-100 hover:bg-slate-700/50 rounded-lg transition-colors flex items-center gap-3"
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-300">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
              </svg>
              Direct Messages
              <span id="sidePanelDMBadge" class="ml-auto bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center hidden">0</span>
            </button>
            <button
              id="sidePanelBlocked"
              class="w-full px-4 py-2.5 text-left text-sm text-slate-100 hover:bg-slate-700/50 rounded-lg transition-colors flex items-center gap-3"
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-300">
                <circle cx="12" cy="12" r="10"/>
                <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/>
              </svg>
              Blocked Users
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Side Panel Overlay -->
    <div
      id="sidePanelOverlay"
      class="fixed inset-0 bg-black/50 backdrop-blur-sm z-40 hidden"
    ></div>

    <!-- Direct Messages Modal -->
    <div
      id="dmModal"
      class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
    >
      <div class="glass-card w-full max-w-5xl rounded-2xl p-4 sm:p-6 max-h-[90vh] overflow-hidden flex flex-col gap-4">
        <div class="flex justify-between items-center">
          <h3 class="text-xl font-semibold text-slate-100">Direct Messages</h3>
          <button
            id="dmCloseBtn"
            class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
          >
            ‚úï
          </button>
        </div>

        <div class="flex flex-col sm:flex-row gap-4 min-h-[60vh]">
          <!-- Conversations list -->
          <div class="sm:w-1/3 bg-slate-900/70 border border-slate-800 rounded-xl p-3 flex flex-col gap-3">
            <div class="flex items-center gap-2">
              <input
                id="dmUserSearch"
                type="text"
                placeholder="Search users..."
                class="w-full px-3 py-2 rounded-lg bg-slate-800 border border-slate-700 focus:border-sky-500 focus:ring-2 focus:ring-sky-500/50 outline-none text-sm"
              />
              <button
                id="dmStartBtn"
                class="px-3 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 text-white text-sm"
              >
                Start
              </button>
            </div>

            <div class="flex-1 overflow-y-auto space-y-2" id="dmConversationList">
              <!-- Conversations injected here -->
            </div>
          </div>

          <!-- Message view -->
          <div class="sm:flex-1 bg-slate-900/70 border border-slate-800 rounded-xl flex flex-col min-h-[50vh]">
            <div class="px-4 py-3 border-b border-slate-800 flex items-center justify-between">
              <div>
                <p class="text-sm text-slate-400">Chatting with</p>
                <p id="dmActiveUser" class="text-base text-slate-100 font-semibold">Select a conversation</p>
              </div>
              <button
                id="dmBlockBtn"
                class="text-xs px-3 py-1.5 rounded-lg bg-red-600 hover:bg-red-700 text-white"
              >
                Block
              </button>
            </div>

            <div id="dmMessages" class="flex-1 overflow-y-auto px-4 py-3 space-y-2 bg-slate-900"></div>

            <form id="dmForm" class="p-3 border-t border-slate-800 flex items-center gap-2">
              <input
                id="dmInput"
                class="flex-1 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700 focus:border-sky-500 focus:ring-2 focus:ring-sky-500/50 outline-none text-sm"
                placeholder="Type a message..."
                autocomplete="off"
              />
              <button
                id="dmSendBtn"
                type="submit"
                class="px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 text-white text-sm font-medium"
              >
                Send
              </button>
            </form>
          </div>
        </div>

        <p id="dmError" class="text-xs text-red-400 min-h-[1rem]"></p>
      </div>
    </div>

    <!-- Notifications Modal -->
    <div
      id="notifModal"
      class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
    >
      <div class="glass-card w-full max-w-md rounded-2xl p-4 sm:p-6 max-h-[80vh] overflow-hidden flex flex-col gap-3">
        <div class="flex items-center justify-between">
          <h3 class="text-lg font-semibold text-slate-100">Notifications</h3>
          <button
            id="notifCloseBtn"
            class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
          >
            ‚úï
          </button>
        </div>
        <div id="notifList" class="flex-1 overflow-y-auto space-y-2 pr-1">
          <p class="text-xs text-slate-400">No notifications yet.</p>
        </div>
        <div class="flex justify-end gap-2 pt-2 border-t border-slate-800">
          <button
            id="notifClearBtn"
            class="px-3 py-2 text-sm rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-100"
          >
            Clear
          </button>
        </div>
      </div>
    </div>

    <!-- Privacy Settings Modal -->
    <div
      id="privacySettingsModal"
      class="fixed inset-0 z-50 modal-closed flex items-center justify-center px-4 bg-black/50 backdrop-blur-sm"
    >
      <div class="glass-card max-w-md w-full rounded-2xl p-6">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-semibold text-slate-100">Privacy Settings</h3>
          <button
            id="privacySettingsCloseBtn"
            class="p-1 hover:bg-slate-700 rounded-lg transition-colors"
          >
            ‚úï
          </button>
        </div>

        <div class="space-y-4">
          <div class="flex items-center justify-between">
            <div>
              <p class="text-sm font-medium text-slate-100">Allow Friend Requests</p>
              <p class="text-xs text-slate-400">Let others send you friend requests</p>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="allowFriendRequestsToggle" class="sr-only peer" checked>
              <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-sky-600"></div>
            </label>
          </div>

          <div class="flex items-center justify-between">
            <div>
              <p class="text-sm font-medium text-slate-100">Allow Direct Messages</p>
              <p class="text-xs text-slate-400">Let friends send you DMs</p>
            </div>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="allowDMsToggle" class="sr-only peer" checked>
              <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-sky-600"></div>
            </label>
          </div>
        </div>

        <button
          id="savePrivacyBtn"
          class="w-full mt-6 px-4 py-2 bg-sky-600 hover:bg-sky-700 text-white rounded-lg transition-colors font-medium"
        >
          Save Settings
        </button>
      </div>
    </div>

    <!-- Delete Message Confirmation Modal -->
    <div
      id="deleteMessageModal"
      class="modal-overlay fixed inset-0 z-50 modal-closed items-center justify-center px-4"
    >
      <div class="glass-card max-w-sm w-full rounded-2xl p-6 border-2 border-red-500/30">
        <div class="flex items-center gap-3 mb-4">
          <div class="w-12 h-12 rounded-full bg-red-500/20 flex items-center justify-center">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-red-500">
              <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              <line x1="10" y1="11" x2="10" y2="17"></line>
              <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
          </div>
          <div>
            <h3 class="text-lg font-semibold text-slate-100">Delete Message</h3>
            <p class="text-sm text-slate-400">This action cannot be undone</p>
          </div>
        </div>

        <p class="text-sm text-slate-300 mb-6">
          Are you sure you want to delete this message? It will be removed for everyone.
        </p>

        <div class="flex gap-3">
          <button
            id="cancelDeleteBtn"
            class="flex-1 px-4 py-2 bg-slate-700 hover:bg-slate-600 text-slate-100 rounded-lg transition-colors font-medium"
          >
            Cancel
          </button>
          <button
            id="confirmDeleteBtn"
            class="flex-1 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors font-medium"
          >
            Delete
          </button>
        </div>
      </div>
    </div>

    <script>
      // --- GLOBAL ERROR LOGGING ---
      window.addEventListener("error", (event) => {
        console.error(
          "[window error]",
          event.message,
          "at",
          event.filename + ":" + event.lineno,
          "details:",
          event.error
        );
      });

      window.addEventListener("unhandledrejection", (event) => {
        console.error("[unhandled rejection]", event.reason);
      });

      // Helper function for detailed error logging
      function logDetailedError(context, error, additionalInfo = {}) {
        const errorObj = {
          timestamp: new Date().toISOString(),
          context,
          message: error?.message || String(error),
          code: error?.code,
          type: error?.constructor?.name,
          ...additionalInfo
        };
        console.error(`[ERROR] ${context}:`, errorObj);
        return errorObj;
      }

      // Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyC945jY7UEh4sOOuuk7OMZVXeIh333kxVk",
        authDomain: "chat-app-710f0.firebaseapp.com",
        projectId: "chat-app-710f0",
        storageBucket: "chat-app-710f0.firebasestorage.app",
        messagingSenderId: "225892837672",
        appId: "1:225892837672:web:f190f3585c4ffbd0f1c81d",
        databaseURL: "https://chat-app-710f0-default-rtdb.firebaseio.com",
      };

      console.log("[init] starting firebase init");

      // Initialize Firebase
      firebase.initializeApp(firebaseConfig);
      const auth = firebase.auth();
      const db = firebase.database();

      console.log("[init] firebase initialized");

      // DOM elements
      const loginForm = document.getElementById("loginForm");
      const registerForm = document.getElementById("registerForm");
      const chatInterface = document.getElementById("chatInterface");
      const loadingScreen = document.getElementById("loadingScreen");

      const loginUsernameInput = document.getElementById("loginUsername");
      const loginPasswordInput = document.getElementById("loginPassword");
      const rememberMeCheckbox = document.getElementById("rememberMe");
      const loginBtn = document.getElementById("loginBtn");
      const loginError = document.getElementById("loginError");
      const loginInfo = document.getElementById("loginInfo");

      const regUsernameInput = document.getElementById("regUsername");
      const regPasswordInput = document.getElementById("regPassword");
      const regPasswordConfirmInput =
        document.getElementById("regPasswordConfirm");
      const registerBtn = document.getElementById("registerBtn");
      const registerError = document.getElementById("registerError");

      const msgInput = document.getElementById("msgInput");
      const sendBtn = document.getElementById("sendBtn");
      const messagesDiv = document.getElementById("messages");
      const messageForm = document.getElementById("messageForm");
      const sendWarningEl = document.getElementById("sendWarning");
      const typingIndicatorEl = document.getElementById("typingIndicator");
      const warningPopup = document.getElementById("warningPopup");
      const warningReason = document.getElementById("warningReason");
      const warningAgree = document.getElementById("warningAgree");
      const closeWarningBtn = document.getElementById("closeWarningBtn");
      const muteInlineBanner = document.getElementById("muteInlineBanner");
      const muteInlineText = document.getElementById("muteInlineText");

      const registerLink = document.getElementById("registerLink");
      const loginLink = document.getElementById("loginLink");
      const logoutBtn = document.getElementById("logoutBtn");
      const chatUserLabel = document.getElementById("chatUserLabel");

      // Global state
      let currentUsername = null; // SINGLE SOURCE for username
      let currentUserId = null;

      // DM state
      let activeDMThread = null;
      let activeDMTarget = null; // { uid, username }
      let dmMessagesRef = null;
      let dmMessagesListener = null;
      let dmInboxRef = null;
      let dmInboxListener = null;
      let dmLastSeenByThread = {};
      let dmLastUpdateTimeByThread = {}; // Track last update time per thread to avoid duplicate notifs
      let dmInboxInitialLoaded = false;

      // Moderation state
      let isAdmin = false;
      let isMuted = false;
      let adminRef = null;
      let adminListener = null;
      let muteRef = null;
      let muteListener = null;
      let warningRef = null;
      let warningListener = null;
      let banRef = null;
      let banListener = null;
      let banCountdownInterval = null;
      let banLogoutTimeout = null;

      // User settings stored in Firebase (no localStorage)
      let userSettingsRef = null;
      async function saveUserSetting(key, value) {
        if (!currentUserId) return;
        try {
          const ref = db.ref("userSettings/" + currentUserId + "/" + key);
          await ref.set(value);
        } catch (err) {
          console.warn("[settings] failed to save", key, err);
        }
      }

      async function loadUserSettings() {
        if (!currentUserId) return { theme: "dark", messageSize: "medium", fastMode: false };
        userSettingsRef = db.ref("userSettings/" + currentUserId);
        try {
          const snap = await userSettingsRef.once("value");
          const data = snap.val() || {};
          return {
            theme: data.theme || "dark",
            messageSize: data.messageSize || "medium",
            fastMode: data.fastMode === true,
          };
        } catch (err) {
          console.warn("[settings] failed to load user settings", err);
          return { theme: "dark", messageSize: "medium", fastMode: false };
        }
      }

      // Friends + notifications
      let friendsCache = new Set();
      let notificationHistory = [];
      let clearedNotificationThreads = new Set(); // Track cleared DM threads
      
      function loadClearedNotifications() {
        if (!currentUserId) return;
        db.ref("userSettings/" + currentUserId + "/clearedNotifications").once("value", (snap) => {
          const cleared = snap.val() || [];
          clearedNotificationThreads = new Set(Array.isArray(cleared) ? cleared : []);
        }).catch(() => {
          clearedNotificationThreads = new Set();
        });
      }
      
      async function saveClearedNotifications() {
        if (!currentUserId) return;
        try {
          await db.ref("userSettings/" + currentUserId + "/clearedNotifications").set(Array.from(clearedNotificationThreads));
        } catch (err) {}
      }
      let originalProfilePic = null;
      let originalProfilePicDeleteToken = null;

      // Message removal listener
      let messagesRemoveRef = null;
      let messagesRemoveListener = null;

      // Real-time messages
      let messagesRef = null;      // realtime ref for new messages
      let messagesListener = null; // child_added listener
      const seenMessageKeys = new Set();
      let blockedUsersCache = new Set(); // Cache of blocked user UIDs

      // Pagination / infinite scroll
      let PAGE_SIZE = 75; // default page size
      let FAST_MODE_ENABLED = false;
      let oldestTime = null;
      let newestTime = null;
      let isLoadingOlder = false;
      let allHistoryLoaded = false;
      let scrollListenerAttached = false;

      // Load blocked users into cache
      async function loadBlockedUsersCache() {
        const uid = auth.currentUser?.uid;
        if (!uid) return;

        try {
          const snap = await db.ref("blockedUsers/" + uid).once("value");
          blockedUsersCache.clear();
          
          if (snap.exists()) {
            const blocked = snap.val();
            Object.keys(blocked).forEach(blockedUid => {
              blockedUsersCache.add(blockedUid);
            });
            console.log("[block] loaded", blockedUsersCache.size, "blocked users into cache");
          }
        } catch (err) {
          console.error("[block] error loading blocked users cache:", err);
        }
      }

      // Load friends into cache for quick checks (notifications, etc.)
      async function loadFriendsCache() {
        const uid = auth.currentUser?.uid;
        if (!uid) return;
        try {
          const snap = await db.ref("friends/" + uid).once("value");
          friendsCache.clear();
          if (snap.exists()) {
            Object.keys(snap.val()).forEach((fid) => friendsCache.add(fid));
          }
          console.log("[friends] loaded", friendsCache.size, "friends into cache");
        } catch (err) {
          console.error("[friends] error loading friends cache:", err);
        }
      }

      // --- Moderation helpers (admin, ban, mute, warnings) ---
      function detachModerationListeners() {
        if (adminRef && adminListener) adminRef.off("value", adminListener);
        if (muteRef && muteListener) muteRef.off("value", muteListener);
        if (warningRef && warningListener) warningRef.off("value", warningListener);
        if (banRef && banListener) banRef.off("value", banListener);
        if (banCountdownInterval) {
          clearInterval(banCountdownInterval);
          banCountdownInterval = null;
        }
        if (banLogoutTimeout) {
          clearTimeout(banLogoutTimeout);
          banLogoutTimeout = null;
        }
        adminRef = muteRef = warningRef = banRef = null;
        adminListener = muteListener = warningListener = banListener = null;
        isAdmin = false;
        isMuted = false;
        if (msgInput) {
          msgInput.disabled = false;
          msgInput.placeholder = "Type a message...";
        }
        if (sendBtn) sendBtn.disabled = false;
        if (warningPopup) warningPopup.classList.add("hidden");
        if (warningAgree) warningAgree.checked = false;
        if (closeWarningBtn) {
          closeWarningBtn.disabled = true;
          closeWarningBtn.classList.add("opacity-50", "cursor-not-allowed");
        }
      }

      function checkAdmin() {
        const uid = firebase.auth().currentUser?.uid;
        if (!uid) return;
        console.log("[checkAdmin] Current user UID:", uid);
        adminRef = firebase.database().ref("admins/" + uid);
        adminListener = (snap) => {
          isAdmin = snap.exists();
          console.log("[checkAdmin] Admin check for uid", uid, "- exists:", isAdmin, "- snap.val():", snap.val());
        };
        adminRef.on("value", adminListener);
      }

      function banUser(uid, durationMinutes = null, reason = "Rule break") {
        if (!isAdmin || !uid) return;
        
        if (durationMinutes === "permanent") {
          // Delete account permanently
          deleteUserAccount(uid, reason);
        } else {
          // Temporary ban
          const until = durationMinutes ? Date.now() + durationMinutes * 60 * 1000 : Date.now() + 3600000; // 1 hour default
          firebase.database().ref("bannedUsers/" + uid).set({
            until: until,
            reason: reason,
          }).catch((err) => {
            console.error("[ban] failed to ban user", err);
          });
        }
      }

      async function deleteUserAccount(uid, reason = "Permanent ban") {
        if (!isAdmin || !uid) return;
        
        try {
          console.log("[ban] deleting account for uid:", uid);
          
          // Get user data
          const userSnap = await db.ref("users").child(uid).once("value");
          const userData = userSnap.val();
          
          // Delete all messages by this user
          const msgsSnap = await db.ref("messages").orderByChild("userId").equalTo(uid).once("value");
          msgsSnap.forEach((childSnap) => {
            db.ref("messages/" + childSnap.key).remove();
          });
          
          // Delete user account
          await db.ref("users/" + uid).remove();
          
          // Block username from being used again (use encoded key)
          if (userData && userData.username) {
            const encodedUsername = encodeFirebaseKey(userData.username);
            await db.ref("bannedUsernames/" + encodedUsername).set({
              uid: uid,
              reason: reason,
              timestamp: Date.now()
            });
          }
          
          // Mark as permanently banned so they can't re-register with same email (use encoded key)
          if (userData && userData.email) {
            const encodedEmail = encodeFirebaseKey(userData.email);
            await db.ref("bannedEmails/" + encodedEmail).set({
              uid: uid,
              reason: reason,
              timestamp: Date.now()
            });
          }
          
          // Add UID to bannedUsers so they're blocked at database level
          console.log("[ban] adding uid to bannedUsers:", uid);
          await db.ref("bannedUsers/" + uid).set({
            until: 9999999999999,
            reason: reason
          });
          console.log("[ban] uid added to bannedUsers successfully");
          
          console.log("[ban] account deleted successfully");
        } catch (err) {
          console.error("[ban] failed to delete account:", err);
        }
      }

      let pendingBanUid = null;

      function showBanReasonModal(uid) {
        pendingBanUid = uid;
        const banReasonModal = document.getElementById("banReasonModal");
        const banReasonCustom = document.getElementById("banReasonCustom");
        const banDuration = document.getElementById("banDuration");
        banReasonCustom.value = "";
        banDuration.value = "60";
        banReasonModal.classList.remove("hidden");
      }

      function setupBanModal() {
        const banReasonModal = document.getElementById("banReasonModal");
        const banReasonConfirm = document.getElementById("banReasonConfirm");
        const banReasonCancel = document.getElementById("banReasonCancel");
        const banReasonCustom = document.getElementById("banReasonCustom");
        const banDuration = document.getElementById("banDuration");
        const banReasonSpam = document.getElementById("banReasonSpam");
        const banReasonAbuse = document.getElementById("banReasonAbuse");
        const banReasonDisruption = document.getElementById("banReasonDisruption");
        const banReasonHarassment = document.getElementById("banReasonHarassment");

        const setReason = (reason) => {
          banReasonCustom.value = reason;
        };

        banReasonSpam.onclick = () => setReason("Spam");
        banReasonAbuse.onclick = () => setReason("Abusive Language");
        banReasonDisruption.onclick = () => setReason("Disruption");
        banReasonHarassment.onclick = () => setReason("Harassment");

        banReasonConfirm.onclick = () => {
          const reason = banReasonCustom.value.trim() || "Rule break";
          const duration = banDuration.value;
          if (pendingBanUid) {
            banUser(pendingBanUid, duration === "permanent" ? "permanent" : parseInt(duration), reason);
            banReasonModal.classList.add("hidden");
            viewProfileCloseBtn.click();
          }
        };

        banReasonCancel.onclick = () => {
          banReasonModal.classList.add("hidden");
          pendingBanUid = null;
        };
      }

      function clearExpiredBan(uid, data) {
        // Remove an expired temp ban so the user is fully unbanned
        if (!uid || !data?.until) return;
        const now = Date.now();
        if (data.until <= now) {
          console.log("[ban] temp ban expired, clearing entry for", uid);
          db.ref("bannedUsers/" + uid).remove().catch((err) => {
            console.error("[ban] failed to clear expired ban", err);
          });
        }
      }

      async function unbanUser(uid) {
        if (!isAdmin || !uid) return;
        console.log("[ban] unbanning user", uid);
        try {
          const updates = { ["bannedUsers/" + uid]: null };

          // Clean up any blocked email/username entries tied to this uid
          const bannedEmailSnap = await db
            .ref("bannedEmails")
            .orderByChild("uid")
            .equalTo(uid)
            .once("value");
          bannedEmailSnap.forEach((childSnap) => {
            updates["bannedEmails/" + childSnap.key] = null;
          });

          const bannedUsernameSnap = await db
            .ref("bannedUsernames")
            .orderByChild("uid")
            .equalTo(uid)
            .once("value");
          bannedUsernameSnap.forEach((childSnap) => {
            updates["bannedUsernames/" + childSnap.key] = null;
          });

          await db.ref().update(updates);
          console.log("[ban] user unbanned");
        } catch (err) {
          console.error("[ban] failed to unban user", err);
        }
      }

      function watchBanStatus(uid) {
        if (!uid) return;
        console.log("[ban] setting up watchBanStatus for uid:", uid);
        banRef = firebase.database().ref("bannedUsers/" + uid);
        banListener = (snap) => {
          const data = snap.val();
          console.log("[ban] watchBanStatus fired - data:", data);

          // If no data or expired temp ban, clear popup and cleanup
          if (!data) {
            if (banCountdownInterval) {
              clearInterval(banCountdownInterval);
              banCountdownInterval = null;
            }
            if (banLogoutTimeout) {
              clearTimeout(banLogoutTimeout);
              banLogoutTimeout = null;
            }
            const banPopup = document.getElementById("banPopup");
            if (banPopup) banPopup.classList.add("hidden");
            return;
          }

          // Clear expired temp bans automatically
          clearExpiredBan(uid, data);

          const now = Date.now();
          if (data.until && data.until <= now) {
            // After cleanup request, just hide any visible UI
            if (banCountdownInterval) {
              clearInterval(banCountdownInterval);
              banCountdownInterval = null;
            }
            if (banLogoutTimeout) {
              clearTimeout(banLogoutTimeout);
              banLogoutTimeout = null;
            }
            const banPopup = document.getElementById("banPopup");
            if (banPopup) banPopup.classList.add("hidden");
            return;
          }

          if (banCountdownInterval) {
            clearInterval(banCountdownInterval);
            banCountdownInterval = null;
          }
          if (banLogoutTimeout) {
            clearTimeout(banLogoutTimeout);
            banLogoutTimeout = null;
          }

          const banPopup = document.getElementById("banPopup");
          const banReason = document.getElementById("banReason");
          
          let isPermanent = false;
          let secondsLeft = 3;
          
          if (!data.until || data.until === 9999999999999) {
            // Permanent ban takes precedence over time-based logic
            isPermanent = true;
            banReason.textContent = "Reason: " + (data.reason || "Rule break") + " (PERMANENT)";
            console.log("[ban] permanent ban detected");
          } else if (data.until && data.until > now) {
            // Temporary ban still active
            secondsLeft = Math.ceil((data.until - now) / 1000);
            banReason.textContent = "Reason: " + (data.reason || "Rule break") + " (Temp ban expires in " + secondsLeft + "s)";
            console.log("[ban] temporary ban for", secondsLeft, "seconds");
          }
          
          banPopup.classList.remove("hidden");
          
          // Only auto-logout for permanent bans
          if (isPermanent) {
            console.log("[ban] showing ban popup, signing out in 3 seconds (permanent ban)");
            
            // Show countdown
            let countdown = 3;
            banCountdownInterval = setInterval(() => {
              countdown--;
              banReason.textContent = "Reason: " + (data.reason || "Rule break") + " (PERMANENT - Logging out in " + countdown + "s)";
              if (countdown <= 0) {
                clearInterval(banCountdownInterval);
                banCountdownInterval = null;
              }
            }, 1000);
            
            banLogoutTimeout = setTimeout(() => {
              console.log("[ban] auto-signing out permanently banned user");
              auth.signOut().catch(() => {});
              banLogoutTimeout = null;
            }, 3000);
          } else {
            // For temporary bans, just show the popup, don't logout
            console.log("[ban] temporary ban - user can try again after ban expires");
            
            // Update countdown
            let countdown = Math.ceil((data.until - Date.now()) / 1000);
            banCountdownInterval = setInterval(() => {
              countdown--;
              if (countdown > 0) {
                banReason.textContent = "Reason: " + (data.reason || "Rule break") + " (Ban expires in " + countdown + "s)";
              } else {
                clearInterval(banCountdownInterval);
                banCountdownInterval = null;
                banReason.textContent = "Reason: " + (data.reason || "Rule break");
                clearExpiredBan(uid, { until: data.until });
              }
            }, 1000);
          }
        };
        banRef.on("value", banListener);
      }

      function muteUser(uid, minutes = 10, reason = "Rule break") {
        if (!isAdmin || !uid) return;
        const until = Date.now() + minutes * 60 * 1000;
        firebase.database().ref("mutedUsers/" + uid).set({
          until: until,
          reason: reason,
        });
      }

      let pendingMuteUid = null;
      let muteTimerInterval = null;

      function showMuteReasonModal(uid) {
        pendingMuteUid = uid;
        const muteReasonModal = document.getElementById("muteReasonModal");
        const muteReasonCustom = document.getElementById("muteReasonCustom");
        const muteDuration = document.getElementById("muteDuration");
        muteReasonCustom.value = "";
        muteDuration.value = "10";
        muteReasonModal.classList.remove("hidden");
      }

      function setupMuteModal() {
        const muteReasonModal = document.getElementById("muteReasonModal");
        const muteReasonConfirm = document.getElementById("muteReasonConfirm");
        const muteReasonCancel = document.getElementById("muteReasonCancel");
        const muteReasonCustom = document.getElementById("muteReasonCustom");
        const muteDuration = document.getElementById("muteDuration");
        const muteReasonSpam = document.getElementById("muteReasonSpam");
        const muteReasonAbuse = document.getElementById("muteReasonAbuse");
        const muteReasonDisruption = document.getElementById("muteReasonDisruption");
        const muteReasonHarassment = document.getElementById("muteReasonHarassment");

        const setReason = (reason) => {
          muteReasonCustom.value = reason;
        };

        muteReasonSpam.onclick = () => setReason("Spam");
        muteReasonAbuse.onclick = () => setReason("Abusive Language");
        muteReasonDisruption.onclick = () => setReason("Disruption");
        muteReasonHarassment.onclick = () => setReason("Harassment");

        muteReasonConfirm.onclick = () => {
          const reason = muteReasonCustom.value.trim() || "Rule break";
          const minutes = parseInt(muteDuration.value) || 10;
          if (pendingMuteUid) {
            muteUser(pendingMuteUid, minutes, reason);
            muteReasonModal.classList.add("hidden");
            viewProfileCloseBtn.click();
          }
        };

        muteReasonCancel.onclick = () => {
          muteReasonModal.classList.add("hidden");
          pendingMuteUid = null;
        };
      }

      function watchMuteStatus(uid) {
        if (!uid) return;
        muteRef = firebase.database().ref("mutedUsers/" + uid);
        muteListener = (snap) => {
          const data = snap.val();
          const now = Date.now();
          const active = data && data.until && data.until > now;
          isMuted = !!active;

          if (active) {
            const timeLeft = Math.ceil((data.until - now) / 1000);
            msgInput.disabled = true;
            sendBtn.disabled = true;
            msgInput.placeholder = "You are muted for " + timeLeft + "s";
            if (muteInlineBanner && muteInlineText) {
              muteInlineBanner.classList.remove("hidden");
              muteInlineText.textContent = "Muted: " + (data.reason || "Rule break") + " ‚Äî " + timeLeft + "s left";
            }
            
            // Show mute popup
            const mutePopup = document.getElementById("mutePopup");
            const muteReason = document.getElementById("muteReason");
            const muteTimer = document.getElementById("muteTimer");
            muteReason.textContent = "Reason: " + (data.reason || "Rule break");
            mutePopup.classList.remove("hidden");
            muteTimer.textContent = timeLeft + "s remaining";
            
            // Update timer every second
            if (muteTimerInterval) clearInterval(muteTimerInterval);
            muteTimerInterval = setInterval(() => {
              const now2 = Date.now();
              const timeLeft2 = Math.ceil((data.until - now2) / 1000);
              if (timeLeft2 <= 0) {
                clearInterval(muteTimerInterval);
                mutePopup.classList.add("hidden");
                msgInput.disabled = false;
                sendBtn.disabled = false;
                msgInput.placeholder = "Type a message...";
                if (muteInlineBanner) muteInlineBanner.classList.add("hidden");
                if (muteInlineText) muteInlineText.textContent = "";
              } else {
                muteTimer.textContent = timeLeft2 + "s remaining";
                msgInput.placeholder = "You are muted for " + timeLeft2 + "s";
                if (muteInlineText) {
                  muteInlineText.textContent = "Muted: " + (data.reason || "Rule break") + " ‚Äî " + timeLeft2 + "s left";
                }
              }
            }, 1000);
          } else {
            if (muteTimerInterval) clearInterval(muteTimerInterval);
            msgInput.disabled = false;
            sendBtn.disabled = false;
            msgInput.placeholder = "Type a message...";
            const mutePopup = document.getElementById("mutePopup");
            mutePopup.classList.add("hidden");
            if (muteInlineBanner) muteInlineBanner.classList.add("hidden");
            if (muteInlineText) muteInlineText.textContent = "";
          }
        };
        muteRef.on("value", muteListener);
      }

      function warnUser(uid, reason) {
        if (!isAdmin || !uid) return;
        firebase.database().ref("warnings/" + uid).set({
          active: true,
          reason: reason || "Rule break",
        });
      }

      let pendingWarnUid = null;

      function showWarnReasonModal(uid) {
        pendingWarnUid = uid;
        const warnReasonModal = document.getElementById("warnReasonModal");
        const warnReasonCustom = document.getElementById("warnReasonCustom");
        warnReasonCustom.value = "";
        warnReasonModal.classList.remove("hidden");
      }

      function setupWarnModal() {
        const warnReasonModal = document.getElementById("warnReasonModal");
        const warnReasonConfirm = document.getElementById("warnReasonConfirm");
        const warnReasonCancel = document.getElementById("warnReasonCancel");
        const warnReasonCustom = document.getElementById("warnReasonCustom");
        const warnReasonSpam = document.getElementById("warnReasonSpam");
        const warnReasonAbuse = document.getElementById("warnReasonAbuse");
        const warnReasonDisruption = document.getElementById("warnReasonDisruption");
        const warnReasonHarassment = document.getElementById("warnReasonHarassment");

        const setReason = (reason) => {
          warnReasonCustom.value = reason;
        };

        warnReasonSpam.onclick = () => setReason("Spam");
        warnReasonAbuse.onclick = () => setReason("Abusive Language");
        warnReasonDisruption.onclick = () => setReason("Disruption");
        warnReasonHarassment.onclick = () => setReason("Harassment");

        warnReasonConfirm.onclick = () => {
          const reason = warnReasonCustom.value.trim() || "Rule break";
          if (pendingWarnUid) {
            warnUser(pendingWarnUid, reason);
            warnReasonModal.classList.add("hidden");
            viewProfileCloseBtn.click();
          }
        };

        warnReasonCancel.onclick = () => {
          warnReasonModal.classList.add("hidden");
          pendingWarnUid = null;
        };
      }

      let warningShownAlready = false;

      function watchWarnings(uid) {
        if (!uid) return;
        warningRef = firebase.database().ref("warnings/" + uid);
        warningListener = (snap) => {
          const data = snap.val();
          if (data && data.active && !warningShownAlready) {
            warningShownAlready = true;
            warningReason.textContent = "Reason: " + (data.reason || "Rule break");
            warningPopup.classList.remove("hidden");
            closeWarningBtn.disabled = true;
            closeWarningBtn.classList.add("opacity-50", "cursor-not-allowed");
            warningAgree.checked = false;
          } else if (!data || !data.active) {
            warningPopup.classList.add("hidden");
          }
        };
        warningRef.on("value", warningListener);
      }

      if (warningAgree && closeWarningBtn) {
        warningAgree.addEventListener("change", () => {
          if (warningAgree.checked) {
            closeWarningBtn.disabled = false;
            closeWarningBtn.classList.remove("opacity-50", "cursor-not-allowed");
          } else {
            closeWarningBtn.disabled = true;
            closeWarningBtn.classList.add("opacity-50", "cursor-not-allowed");
          }
        });

        closeWarningBtn.addEventListener("click", () => {
          const uid = firebase.auth().currentUser?.uid;
          if (!uid) return;
          warningShownAlready = false;
          firebase.database().ref("warnings/" + uid).remove().catch(() => {});
          warningPopup.classList.add("hidden");
        });
      }

      function updateNotifBadge() {
        if (!notifBellBadge || !currentUserId) {
          notifBellBadge?.classList.add("hidden");
          return;
        }
        const count = notificationHistory.filter(n => n.isDM).length;
        if (count > 0) {
          notifBellBadge.textContent = count;
          notifBellBadge.classList.remove("hidden");
        } else {
          notifBellBadge.classList.add("hidden");
        }
      }

      async function clearNotifications() {
        // Mark all current DM notifications as cleared
        notificationHistory.forEach(n => {
          if (n.isDM && n.threadId) {
            clearedNotificationThreads.add(n.threadId);
          }
        });
        await saveClearedNotifications();
        
        updateNotifBadge();
        renderNotificationHistory();
      }

      function renderNotificationHistory() {
        notifList.innerHTML = "";
        if (!notificationHistory.length) {
          notifList.innerHTML = '<p class="text-xs text-slate-400">No notifications yet.</p>';
          return;
        }
        notificationHistory
          .slice()
          .sort((a, b) => b.time - a.time)
          .forEach((item) => {
            const row = document.createElement("div");
            row.className = "p-3 rounded-lg bg-slate-800/70 border border-slate-700";
            const title = document.createElement("div");
            title.className = "text-sm text-slate-100 font-semibold";
            title.textContent = item.title;
            const body = document.createElement("div");
            body.className = "text-xs text-slate-300 mt-1";
            body.textContent = item.body;
            const time = document.createElement("div");
            time.className = "text-[11px] text-slate-500 mt-1";
            time.textContent = new Date(item.time).toLocaleString();
            if (item.threadId) {
              row.classList.add("cursor-pointer", "hover:bg-slate-700/70");
              row.addEventListener("click", () => {
                openDmModal();
                selectDmThread(item.threadId, item.withUid || null, item.withUsername || null);
              });
            }
            row.appendChild(title);
            row.appendChild(body);
            row.appendChild(time);
            notifList.appendChild(row);
          });
      }

      function addNotification(title, body, extra = {}) {
        notificationHistory.push({ title, body, time: Date.now(), ...extra });
        if (notificationHistory.length > 50) {
          notificationHistory = notificationHistory.slice(-50);
        }
        updateNotifBadge();
        renderNotificationHistory();
        if ("Notification" in window && Notification.permission === "granted") {
          try {
            new Notification(title, {
              body: body,
              icon: "https://raw.githubusercontent.com/twitter/twemoji/master/assets/72x72/1f4ac.png",
              tag: extra.threadId || "chatra-notif"
            });
          } catch (err) {}
        }
      }

      // Check if a message is from a blocked user
      function isMessageFromBlockedUser(msg) {
        if (!msg || !msg.userId) return false;
        return blockedUsersCache.has(msg.userId);
      }

      // Typing status
      let typingTimeoutId = null;
      let typingListenerAttached = false;
      const TYPING_CLEANUP_INTERVAL = 5000; // Clean up stale typing status every 5s
      let typingCleanupInterval = null;

      // Rate-limit warning timeout + local last-sent time
      let sendWarningTimeoutId = null;
      let lastSentTime = 0; // for local rate limit
      const TEXT_COOLDOWN_MS = 500;   // 0.5s between text sends (matches rules)
      const MEDIA_COOLDOWN_MS = 1000; // 1s between media sends (matches rules)

      // Basic bad-word filter (client-side)
      const BAD_WORDS = [
        "fuck",
        "shit",
        "bitch",
        "faggot",
        "fag",
        "asshole",
        "nigger",
        "cunt",
        "bastard",
        "slut",
        "whore"
      ];
      const badWordPattern = new RegExp("\\b(" + BAD_WORDS.map((w) => w.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")).join("|") + ")\\b", "i");

      // Local hard-blocked usernames (client-side only, case-insensitive). Edit this list as needed.
      const LOCAL_BLOCKED_USERNAMES = [
        "admin",
        "moderator",
        "support",
        "owner",
        "system",
        "staff",
        "fag",
        "faggot",
        "nigger",
        "chink"
      ];

      function isLocallyBlockedUsername(name) {
        if (!name) return false;
        const lower = name.toLowerCase();
        return LOCAL_BLOCKED_USERNAMES.some((n) => n.toLowerCase() === lower);
      }
      
      // Message rendering optimization
      let messageRenderQueue = [];
      let isRenderingMessages = false;

      // --- COMBINED STATUS BAR (typing + warning) ---
      let lastTypingText = "";
      let currentWarningText = "";

      function updateStatusBar() {
        const parts = [];
        if (lastTypingText) parts.push(lastTypingText);
        if (currentWarningText) {
          if (parts.length > 0) {
            parts.push("‚Ä¢ " + currentWarningText);
          } else {
            parts.push(currentWarningText);
          }
        }
        typingIndicatorEl.textContent = parts.join(" ");
        // keep the old warning element visually empty
        if (sendWarningEl) sendWarningEl.textContent = "";
      }

      // Helper: clear messages
      function clearLoginMessages() {
        loginError.textContent = "";
        loginInfo.textContent = "";
      }

      // ===== AUTO-CREATE FIREBASE PATHS =====
      async function ensureUserProfilePath(uid) {
        try {
          const ref = db.ref("userProfiles/" + uid);
          const snap = await ref.once("value");
          if (!snap.exists()) {
            await ref.set({
              username: currentUsername,
              bio: "",
              profilePic: null,
              createdAt: firebase.database.ServerValue.TIMESTAMP,
            });
            console.log("[init] auto-created userProfiles path for", uid);
          }
        } catch (err) {
          console.warn("[init] could not ensure profile path:", err);
        }
      }

      async function ensureUsernamePath(uid, username) {
        try {
          const ref = db.ref("users/" + uid + "/username");
          const snap = await ref.once("value");
          if (!snap.exists()) {
            await ref.set(username);
            console.log("[init] auto-created username path for", uid);
          }
        } catch (err) {
          console.warn("[init] could not ensure username path:", err);
        }
      }

      async function ensureFriendRequestsPaths(uid) {
        try {
          const ref = db.ref("friendRequests/" + uid + "/incoming");
          const snap = await ref.once("value");
          if (!snap.exists()) {
            await ref.set({});
            console.log("[init] auto-created friendRequests incoming path for", uid);
          }
        } catch (err) {
          console.warn("[init] could not ensure friendRequests path:", err);
        }
      }

      async function ensureFriendsList(uid) {
        try {
          const ref = db.ref("friends/" + uid);
          const snap = await ref.once("value");
          if (!snap.exists()) {
            await ref.set({});
            console.log("[init] auto-created friends list for", uid);
          }
        } catch (err) {
          console.warn("[init] could not ensure friends list:", err);
        }
      }

      // Try to ensure another user's incoming friendRequests path exists.
      // This is best-effort: if rules prevent creating it, we'll log and continue.
      async function ensureTargetFriendRequestsIncoming(targetUid) {
        try {
          // First ensure the parent /friendRequests/{uid} node exists
          const parentRef = db.ref("friendRequests/" + targetUid);
          const parentSnap = await parentRef.once("value");
          if (!parentSnap.exists()) {
            await parentRef.set({});
            console.log("[init] auto-created friendRequests parent for target", targetUid);
          }
          
          // Then ensure the /incoming child exists
          const incomingRef = db.ref("friendRequests/" + targetUid + "/incoming");
          const incomingSnap = await incomingRef.once("value");
          if (!incomingSnap.exists()) {
            await incomingRef.set({});
            console.log("[init] auto-created friendRequests incoming for target", targetUid);
          }
        } catch (err) {
          // Permission denied is common if rules disallow creating other users' nodes.
          // Don't block the flow ‚Äî just log details for debugging.
          logDetailedError("ensureTargetFriendRequestsIncoming", err, { targetUid });
        }
      }

      function clearRegisterMessages() {
        registerError.textContent = "";
      }

      // Ensure another user's /friends/{uid} path exists
      async function ensureTargetFriendsList(targetUid) {
        try {
          const ref = db.ref("friends/" + targetUid);
          const snap = await ref.once("value");
          if (!snap.exists()) {
            await ref.set({});
            console.log("[init] auto-created friends list for target", targetUid);
          }
        } catch (err) {
          logDetailedError("ensureTargetFriendsList", err, { targetUid });
        }
      }

      function updateChatUserLabel(username) {
        currentUsername = username || null;
        const ownerUid = "u5yKqiZvioWuBGcGK3SWUBpUVrc2";
        const isOwner = auth.currentUser?.uid === ownerUid;
        if (currentUsername && isOwner) {
          const crownIcon = '<svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="text-amber-300" style="transform: translateY(2px);"><path d="M4 7l3.5 3 4.5-6 4.5 6L20 7v10H4z"></path><path d="M4 17h16v2H4z"></path></svg>';
          const ownerBadge = '<span class="text-[10px] px-2 py-0.5 rounded-full bg-amber-500/15 text-amber-100 border border-amber-400/40">Owner</span>';
          chatUserLabel.innerHTML = '<span class="inline-flex items-center gap-1.5">' + crownIcon + '<span class="font-semibold text-slate-100">' + currentUsername + '</span>' + ownerBadge + '</span>';
        } else {
          chatUserLabel.textContent = currentUsername || "";
        }
        console.log("[ui] chat user label set to:", currentUsername || "");
      }

      // On-screen warning (2 seconds) ‚Äî now combined with typing in one line
      function showRateLimitWarning() {
        currentWarningText = "Slow down!";
        if (sendWarningTimeoutId) {
          clearTimeout(sendWarningTimeoutId);
        }
        updateStatusBar();
        sendWarningTimeoutId = setTimeout(() => {
          currentWarningText = "";
          updateStatusBar();
        }, 2000);
      }

      // --- USERNAME FROM DB (ONE SOURCE OF TRUTH) ---
      async function fetchUsername(uid, emailFallback) {
        try {
          const snap = await db.ref("users/" + uid + "/username").once("value");
          let username = snap.val();
          
          if (!username && emailFallback) {
            username = emailFallback.split("@")[0];
            console.log("[username] no username in DB, using email:", username);
            // Auto-save to DB for next time
            try {
              await db.ref("users/" + uid + "/username").set(username);
            } catch (e) {
              console.warn("[username] could not auto-save username:", e);
            }
          }
          
          return username || "User";
        } catch (err) {
          console.error("[username] error fetching from DB:", err);
          if (emailFallback) {
            const fallback = emailFallback.split("@")[0];
            console.log("[username] using email fallback:", fallback);
            return fallback;
          }
          return "User";
        }
      }

      // On load: no local remember-me persistence; checkbox starts unchecked
      (function initRememberMe() {
        rememberMeCheckbox.checked = false;
      })();

      // Switch to Register form
      registerLink.onclick = () => {
        clearLoginMessages();
        loginForm.classList.add("hidden");
        registerForm.classList.remove("hidden");
        console.log("[ui] switched to register form");
      };

      // Switch to Login form
      loginLink.onclick = () => {
        clearRegisterMessages();
        registerForm.classList.add("hidden");
        loginForm.classList.remove("hidden");
        console.log("[ui] switched to login form");
      };

      // Get modal elements
      const termsModal = document.getElementById("termsModal");
      const privacyModal = document.getElementById("privacyModal");
      const termsLink = document.getElementById("termsLink");
      const privacyLink = document.getElementById("privacyLink");
      const termsCloseBtn = document.getElementById("termsCloseBtn");
      const termsCloseBtn2 = document.getElementById("termsCloseBtn2");
      const privacyCloseBtn = document.getElementById("privacyCloseBtn");
      const privacyCloseBtn2 = document.getElementById("privacyCloseBtn2");

      // Terms of Service modal handlers (guarded for safety)
      if (termsLink && termsModal && termsCloseBtn && termsCloseBtn2) {
        termsLink.onclick = (e) => {
          e.preventDefault();
          termsModal.classList.remove("modal-closed");
          termsModal.classList.add("modal-open");
          console.log("[ui] opened terms modal");
        };

        termsCloseBtn.onclick = () => {
          termsModal.classList.add("modal-closed");
          termsModal.classList.remove("modal-open");
          console.log("[ui] closed terms modal");
        };

        termsCloseBtn2.onclick = () => {
          termsModal.classList.add("modal-closed");
          termsModal.classList.remove("modal-open");
          console.log("[ui] closed terms modal");
        };

        termsModal.onclick = (e) => {
          if (e.target === termsModal) {
            termsModal.classList.add("modal-closed");
            termsModal.classList.remove("modal-open");
          }
        };
      } else {
        console.warn("[ui] terms modal elements missing");
      }

      // Privacy Policy modal handlers (guarded for safety)
      if (privacyLink && privacyModal && privacyCloseBtn && privacyCloseBtn2) {
        privacyLink.onclick = (e) => {
          e.preventDefault();
          privacyModal.classList.remove("modal-closed");
          privacyModal.classList.add("modal-open");
          console.log("[ui] opened privacy modal");
        };

        privacyCloseBtn.onclick = () => {
          privacyModal.classList.add("modal-closed");
          privacyModal.classList.remove("modal-open");
          console.log("[ui] closed privacy modal");
        };

        privacyCloseBtn2.onclick = () => {
          privacyModal.classList.add("modal-closed");
          privacyModal.classList.remove("modal-open");
          console.log("[ui] closed privacy modal");
        };

        privacyModal.onclick = (e) => {
          if (e.target === privacyModal) {
            privacyModal.classList.add("modal-closed");
            privacyModal.classList.remove("modal-open");
          }
        };
      } else {
        console.warn("[ui] privacy modal elements missing");
      }

      // Helper: encode key for Firebase (replace invalid chars: . # $ [ ])
      function encodeFirebaseKey(key) {
        return key
          .replace(/\./g, "_DOT_")
          .replace(/#/g, "_HASH_")
          .replace(/\$/g, "_DOLLAR_")
          .replace(/\[/g, "_LBRACKET_")
          .replace(/\]/g, "_RBRACKET_");
      }

      // Helper: make fake email from username
      function makeEmailFromUsername(username) {
        return username.toLowerCase() + "@gmail.com";
      }

      // Helper: fetch UID by username
      async function getUidByUsername(username) {
        const snap = await db
          .ref("users")
          .orderByChild("username")
          .equalTo(username)
          .limitToFirst(1)
          .once("value");
        if (!snap.exists()) return null;
        const val = snap.val();
        const uid = Object.keys(val)[0];
        return uid || null;
      }

      // Helper: sorted thread id for two UIDs
      function makeThreadId(uidA, uidB) {
        return [uidA, uidB].sort().join("__");
      }

      function clearDmMessages() {
        dmMessages.innerHTML = "";
      }

      function detachDmMessagesListener() {
        if (dmMessagesRef && dmMessagesListener) {
          dmMessagesRef.off("child_added", dmMessagesListener);
        }
        dmMessagesRef = null;
        dmMessagesListener = null;
      }

      function detachDmInboxListener() {
        if (dmInboxRef && dmInboxListener) {
          dmInboxRef.off("value", dmInboxListener);
        }
        dmInboxRef = null;
        dmInboxListener = null;
      }

      function renderDmMessage(msg) {
        const mine = msg.fromUid === currentUserId;
        const row = document.createElement("div");
        row.className = mine ? "flex justify-end" : "flex justify-start";

        const bubble = document.createElement("div");
        bubble.className = `message-bubble-anim max-w-[80%] px-4 py-2 rounded-2xl text-sm border ${
          mine
            ? "mine bg-gradient-to-r from-sky-500 to-blue-600 text-white border-sky-600 shadow-lg shadow-sky-900/40"
            : "bg-slate-800/90 text-slate-100 border-slate-700"
        }`;
        bubble.textContent = msg.text || "";
        row.appendChild(bubble);

        dmMessages.appendChild(row);
        dmMessages.scrollTop = dmMessages.scrollHeight;
      }

      async function isBlockedByTarget(targetUid) {
        if (!currentUserId || !targetUid) return false;
        try {
          const snap = await db
            .ref("blockedUsers/" + targetUid + "/" + currentUserId)
            .once("value");
          return snap.exists();
        } catch (e) {
          // If permission denied (expected due to rules), treat as not knowable and let server-side rules enforce
          if (e?.code === "PERMISSION_DENIED") {
            return false;
          }
          console.warn("[dm] blockedBy check failed", e);
          return false;
        }
      }

      function startDmMessagesListener(threadId) {
        detachDmMessagesListener();
        clearDmMessages();
        dmMessagesRef = db.ref("dms/" + threadId + "/messages");
        dmMessagesListener = dmMessagesRef
          .orderByChild("time")
          .limitToLast(200)
          .on("child_added", (snap) => {
            const msg = snap.val();
            if (!msg) return;
            renderDmMessage(msg);
            
            // Update inbox and fire notification if new message from other user
            if (activeDMTarget && msg.fromUid !== currentUserId && dmInboxInitialLoaded) {
              const now = Date.now();
              db.ref("dmInbox/" + currentUserId + "/" + threadId).update({
                withUid: activeDMTarget.uid,
                withUsername: activeDMTarget.username || activeDMTarget.uid,
                lastMsg: msg.text,
                lastTime: now
              }).catch(() => {});
              
              // Fire notification
              const who = activeDMTarget.username || "Someone";
              const preview = previewText(msg.text || "(no text)", 80);
              addNotification("New DM", `${who}: ${preview}`, {
                threadId: threadId,
                withUid: activeDMTarget.uid,
                withUsername: activeDMTarget.username,
              });
            }
          });
      }

      function verifyNotificationsLoaded() {
        if (!currentUserId) return;
        updateNotifBadge();
      }

      async function loadDmInbox() {
        if (!currentUserId) return;
        detachDmInboxListener();
        
        dmInboxRef = db.ref("dmInbox/" + currentUserId);
        
        // First, load all existing threads into notifications history on initial load
        if (!dmInboxInitialLoaded) {
          try {
            const snapshot = await dmInboxRef.once("value");
            const data = snapshot.val() || {};
            const entries = Object.entries(data)
              .map(([threadId, info]) => ({ threadId, ...info }))
              .sort((a, b) => (b.lastTime || 0) - (a.lastTime || 0));
            
            // Add all threads as notifications for notification history
            entries.forEach((item) => {
              // Skip if this thread was already cleared
              if (clearedNotificationThreads.has(item.threadId)) return;
              // Skip if no last message recorded (prevents false notifs on empty threads)
              if (!item.lastMsg) return;

              const who = item.withUsername || item.withUid || "Someone";
              const preview = previewText(item.lastMsg, 80);
              
              // Check if we already have this notification
              const exists = notificationHistory.some(n => n.threadId === item.threadId);
              if (!exists) {
                addNotification(who, preview, {
                  threadId: item.threadId,
                  withUid: item.withUid,
                  withUsername: item.withUsername,
                  isDM: true,
                  loaded: true
                });
              }

              // Track last update time so we only notify on newer messages later
              dmLastUpdateTimeByThread[item.threadId] = item.lastTime || 0;
            });
          } catch (err) {
            console.error("[dmInbox] Error loading initial notifications:", err);
          }
        }
        
        dmInboxListener = dmInboxRef.on("value", (snap) => {
          const data = snap.val() || {};
          const entries = Object.entries(data)
            .map(([threadId, info]) => ({ threadId, ...info }))
            .sort((a, b) => (b.lastTime || 0) - (a.lastTime || 0));

          let unreadThreadsCount = 0;

          entries.forEach((item) => {
            const lastTime = item.lastTime || 0;
            const lastSeen = dmLastSeenByThread[item.threadId] || 0;
            const isActiveThread = activeDMThread === item.threadId && dmModal.classList.contains("modal-open");

            // Mark active thread as seen
            if (isActiveThread && lastTime > lastSeen) {
              dmLastSeenByThread[item.threadId] = lastTime;
            }

            // Fire notification only for new messages with a lastMsg and only if not viewing this thread
            const lastNotifiedTime = dmLastUpdateTimeByThread[item.threadId] || 0;
            if (!isActiveThread && dmInboxInitialLoaded && lastTime > lastNotifiedTime && item.lastMsg) {
              const who = item.withUsername || item.withUid || "Someone";
              const preview = previewText(item.lastMsg, 80);
              addNotification(who, preview, {
                threadId: item.threadId,
                withUid: item.withUid,
                withUsername: item.withUsername,
                isDM: true
              });
            }

            if (isActiveThread) {
              dmLastSeenByThread[item.threadId] = lastTime;
            }

            // Update last notified/seen time to current lastTime (only if we have a message)
            dmLastUpdateTimeByThread[item.threadId] = Math.max(item.lastMsg ? lastTime : 0, dmLastUpdateTimeByThread[item.threadId] || 0);

            const hasUnread = lastTime > lastSeen && !isActiveThread;
            if (hasUnread) {
              unreadThreadsCount += 1;
            }
          });

          dmInboxInitialLoaded = true;
        });
      }

      async function selectDmThread(threadId, targetUid, targetUsername) {
        if (!currentUserId) return;
        let resolvedUsername = targetUsername;
        if (!resolvedUsername && targetUid) {
          try {
            const nameSnap = await db.ref("users/" + targetUid + "/username").once("value");
            resolvedUsername = nameSnap.val() || targetUid;
          } catch (e) {
            resolvedUsername = targetUid;
          }
        }
        activeDMThread = threadId;
        activeDMTarget = { uid: targetUid, username: resolvedUsername };
        dmActiveUser.textContent = resolvedUsername;
        dmError.textContent = "";
        
        const now = Date.now();
        dmLastSeenByThread[threadId] = now;
        
        // Clear DM notifications for this thread
        notificationHistory = notificationHistory.filter(n => n.threadId !== threadId);
        updateNotifBadge();
        renderNotificationHistory();
        
        // Ensure self is participant and create own inbox entry
        await Promise.all([
          db.ref("dms/" + threadId + "/participants/" + currentUserId).set(true).catch(() => {}),
          db.ref("dmInbox/" + currentUserId + "/" + threadId).set({
            withUid: targetUid,
            withUsername: resolvedUsername || targetUid,
            lastTime: now
          }).catch(() => {})
        ]);
        
        startDmMessagesListener(threadId);
      }

      async function ensureDmThread(targetUid, targetUsername) {
        const threadId = makeThreadId(currentUserId, targetUid);
        // Create/ensure DM thread and add self as participant
        const participantsRef = db.ref("dms/" + threadId + "/participants");
        await participantsRef.child(currentUserId).set(true);
        return threadId;
      }

      async function startDmWithUsername(username) {
        if (!currentUserId) {
          dmError.textContent = "Please log in.";
          return;
        }
        const target = (username || "").trim();
        if (!target) {
          dmError.textContent = "Enter a username.";
          return;
        }
        if (target === currentUsername) {
          dmError.textContent = "You cannot DM yourself.";
          return;
        }
        dmError.textContent = "";
        try {
          const targetUid = await getUidByUsername(target);
          if (!targetUid) {
            dmError.textContent = "User not found.";
            return;
          }
          if (blockedUsersCache.has(targetUid)) {
            dmError.textContent = "You blocked this user.";
            return;
          }

          if (await isBlockedByTarget(targetUid)) {
            dmError.textContent = "You are blocked by this user.";
            return;
          }

          const allowSnap = await db
            .ref("userPrivacy/" + targetUid + "/allowDMs")
            .once("value");
          if (allowSnap.exists() && allowSnap.val() === false) {
            dmError.textContent = "This user is not accepting DMs.";
            return;
          }
          const threadId = await ensureDmThread(targetUid, target);
          await selectDmThread(threadId, targetUid, target);
          dmModal.classList.add("modal-open");
          dmModal.classList.remove("modal-closed");
        } catch (err) {
          console.error("[dm] start error", err);
          dmError.textContent = err.message || "Could not start DM.";
        }
      }

      // üîç Check if username is already taken in DB
      async function isUsernameTaken(username) {
        console.log("[users] checking if username taken:", username);
        try {
          // Local blocked list first (fast)
          if (isLocallyBlockedUsername(username)) {
            console.log("[users] username blocked locally:", username);
            return true;
          }

          // Check if username is in use
          const snapshot = await db
            .ref("users")
            .orderByChild("username")
            .equalTo(username)
            .once("value");
          const exists = snapshot.exists();

          // Check if username is banned (supports key-based or value-based name field)
          let isBanned = false;
          const bannedSnap = await db.ref("bannedUsernames").once("value");
          if (bannedSnap.exists()) {
            bannedSnap.forEach((child) => {
              if (isBanned) return; // short-circuit
              const val = child.val();
              const keyName = child.key;
              const valueName = typeof val === "object" && val !== null ? val.name : null;
              if (
                (keyName && keyName.toLowerCase() === username.toLowerCase()) ||
                (valueName && valueName.toLowerCase() === username.toLowerCase())
              ) {
                isBanned = true;
              }
            });
          }
          
          console.log("[users] username taken =", exists, "banned =", isBanned);
          return exists || isBanned || badWordPattern.test(username);
        } catch (err) {
          console.error("[users] error while checking username", err);
          registerError.textContent = "Error checking username. Try again.";
          return true;
        }
      }

      // Register User (username + password + confirm)
      registerBtn.onclick = async () => {
        clearRegisterMessages();

        const username = regUsernameInput.value.trim();
        const password = regPasswordInput.value.trim();
        const passwordConfirm = regPasswordConfirmInput.value.trim();

        console.log("[register] submit", { username });

        if (!username || !password || !passwordConfirm) {
          registerError.textContent = "Please fill all fields.";
          return;
        }

        if (username.includes("@") || username.includes(" ")) {
          registerError.textContent = "Username can't have spaces or '@'.";
          return;
        }

        if (username.length < 3 || username.length > 12) {
          registerError.textContent = "Username must be 3-12 characters.";
          return;
        }

        if (!/^[a-zA-Z0-9_-]+$/.test(username) || /^[_-]|[_-]$/.test(username)) {
          registerError.textContent = "Use letters/numbers/underscore/dash (no leading/trailing _ or -).";
          return;
        }

        if (badWordPattern.test(username)) {
          registerError.textContent = "Username not allowed.";
          return;
        }

        if (isLocallyBlockedUsername(username)) {
          registerError.textContent = "Username not allowed.";
          return;
        }

        if (password !== passwordConfirm) {
          registerError.textContent = "Passwords do not match.";
          return;
        }

        // Check username in database
        if (await isUsernameTaken(username)) {
          if (!registerError.textContent) {
            registerError.textContent = "That username is already taken.";
          }
          return;
        }

        const fakeEmail = makeEmailFromUsername(username);
        console.log("[register] creating auth user", fakeEmail);

        try {
          const userCredential = await auth.createUserWithEmailAndPassword(
            fakeEmail,
            password
          );
          const user = userCredential.user;
          console.log("[register] auth user created", user.uid);

          // Save the username in Firebase Database
          const userRef = db.ref("users/" + user.uid);
          await userRef.set({ username });
          console.log("[register] username saved to /users", user.uid);
          
          // Auto-create profile path
          try {
            await db.ref("userProfiles/" + user.uid).set({
              username: username,
              bio: "",
              profilePic: null,
              createdAt: firebase.database.ServerValue.TIMESTAMP,
            });
            console.log("[register] auto-created userProfiles", user.uid);
            
            // Also create friend requests and friends paths
            await db.ref("friendRequests/" + user.uid + "/incoming").set({});
            await db.ref("friends/" + user.uid).set({});
            console.log("[register] auto-created friend paths", user.uid);
          } catch (e) {
            console.warn("[register] could not create paths:", e);
          }

          // Keep them logged in after registration
          console.log("[register] registration complete, staying logged in");
          
          // Hide the register form
          registerForm.classList.add("hidden");
        } catch (error) {
          console.error("[register] Error registering:", error);
          if (error.code === "auth/email-already-in-use") {
            registerError.textContent = "That username is already taken.";
          } else if (error.code === "auth/weak-password") {
            registerError.textContent = "Password is too weak.";
          } else {
            registerError.textContent = "Could not register. Try again.";
          }
        }
      };

      /// Sign In User (username + password only) with persistence
      loginBtn.onclick = async () => {
        clearLoginMessages();

        const username = loginUsernameInput.value.trim();
        const password = loginPasswordInput.value.trim();
        const remember = rememberMeCheckbox.checked;
        console.log("[login] submit", { username, remember });

        if (!username || !password) {
          loginError.textContent = "Please fill username and password.";
          return;
        }

        if (username.includes("@") || username.includes(" ")) {
          loginError.textContent = "Username can't have spaces or '@'.";
          return;
        }

        const fakeEmail = makeEmailFromUsername(username);

        try {
          // Check if email/username is banned (use encoded keys)
          const encodedEmail = encodeFirebaseKey(fakeEmail);
          const encodedUsername = encodeFirebaseKey(username);
          
          const bannedEmailSnap = await db.ref("bannedEmails/" + encodedEmail).once("value");
          const bannedUsernameSnap = await db.ref("bannedUsernames/" + encodedUsername).once("value");
          
          if (bannedEmailSnap.exists() || bannedUsernameSnap.exists()) {
            const bannedReason = bannedEmailSnap.val()?.reason || bannedUsernameSnap.val()?.reason || "Account has been permanently banned";
            loginError.textContent = "This account is banned: " + bannedReason;
            return;
          }

          const persistence = remember
            ? firebase.auth.Auth.Persistence.LOCAL
            : firebase.auth.Auth.Persistence.SESSION;

          console.log(
            "[login] setting persistence",
            remember ? "LOCAL" : "SESSION"
          );
          
          try {
            await auth.setPersistence(persistence);
          } catch (e) {
            console.warn("[login] persistence not available (incognito?):", e);
            // Continue anyway, will just be session-based
          }

          console.log("[login] signing in with email", fakeEmail);

          const userCredential = await auth.signInWithEmailAndPassword(
            fakeEmail,
            password
          );
          const user = userCredential.user;

          console.log("[login] signed in as", user.uid);
          
          // Auto-ensure paths exist
          try {
            await ensureUsernamePath(user.uid, username);
            await ensureUserProfilePath(user.uid);
            await ensureFriendRequestsPaths(user.uid);
            await ensureFriendsList(user.uid);
          } catch (e) {
            console.warn("[login] could not ensure paths:", e);
            // Continue anyway - these aren't critical
          }

          // DO NOT show chat here. onAuthStateChanged will do it.
        } catch (error) {
          console.error("[login] Error signing in:", error);
          if (
            error.code === "auth/user-not-found" ||
            error.code === "auth/wrong-password"
          ) {
            loginError.textContent = "Wrong username or password.";
          } else if (error.code === "auth/too-many-requests") {
            loginError.textContent =
              "Too many attempts. Please wait and try again.";
          } else {
            loginError.textContent = "Could not log in. Try again.";
          }
        }
      };

      // Profile cache to avoid excessive DB lookups
      const profileCache = {};

      // Delete message function
      async function deleteMessage(messageId, deleteToken) {
        if (!messageId) {
          console.error("[delete] no messageId provided");
          return;
        }

        try {
          console.log("[delete] deleting message", messageId);

          // Delete from Cloudinary if has deleteToken
          if (deleteToken) {
            try {
              await deleteFromCloudinary(deleteToken);
              console.log("[delete] deleted media from Cloudinary");
            } catch (err) {
              console.warn("[delete] failed to delete from Cloudinary, continuing", err);
            }
          }

          // Delete from Firebase
          await db.ref("messages/" + messageId).remove();
          console.log("[delete] deleted message from Firebase");

          // Remove from DOM
          const messageElements = messagesDiv.querySelectorAll(".message-bubble-anim");
          messageElements.forEach(el => {
            const parent = el.closest(".w-full");
            if (parent && parent.dataset.messageId === messageId) {
              parent.remove();
            }
          });

        } catch (err) {
          console.error("[delete] error deleting message", err);
          alert("Failed to delete message: " + (err.message || "Unknown error"));
        }
      }

      // Fetch user profile data with timeout
      // Pending profile requests for deduplication
      const pendingProfileRequests = new Map();

      async function fetchUserProfile(username) {
        // Return cached result if available and recent (5 minutes)
        if (profileCache[username]) {
          const cached = profileCache[username];
          const now = Date.now();
          if (cached._timestamp && (now - cached._timestamp) < 300000) {
            return cached;
          }
        }
        
        // Deduplicate concurrent requests for same username
        if (pendingProfileRequests.has(username)) {
          return pendingProfileRequests.get(username);
        }
        
        const fetchPromise = (async () => {
          try {
            // Set a timeout for the fetch
            const timeoutPromise = new Promise((_, reject) => 
              setTimeout(() => reject(new Error("timeout")), 2000)
            );

            const dataPromise = (async () => {
              const snap = await db.ref("users").orderByChild("username").equalTo(username).once("value");
              if (snap.exists()) {
                const uid = Object.keys(snap.val())[0];
                const profileSnap = await db.ref("userProfiles/" + uid).once("value");
                const data = profileSnap.val() || {};
                profileCache[username] = { uid, ...data, _timestamp: Date.now() };
                return profileCache[username];
              }
              return null;
            })();

            return await Promise.race([dataPromise, timeoutPromise]);
          } catch (err) {
            return null;
          } finally {
            pendingProfileRequests.delete(username);
          }
        })();
        
        pendingProfileRequests.set(username, fetchPromise);
        return fetchPromise;
      }

      // --- MESSAGE RENDERING (bigger iMessage-style bubbles) ---
      function createMessageRow(msg, messageId = null) {
        const myName = currentUsername || null;
        const isMine = myName && msg.user === myName;
        const username = msg.user || "Unknown";
        const ownerUid = "u5yKqiZvioWuBGcGK3SWUBpUVrc2";
        const isOwnerMessage = msg.userId === ownerUid;
        const staffUid = "6n8hjmrUxhMHskX4BG8Ik9boMqa2";
        const isStaffMessage = msg.userId === staffUid;

        const row = document.createElement("div");
        row.className = isMine 
          ? "w-full flex mb-2 sm:mb-2 justify-end pr-1 sm:pr-3 gap-2 items-end"
          : "w-full flex mb-2 sm:mb-2 justify-start pl-1 sm:pl-3 gap-2 items-end";
        
        // Store messageId in dataset for deletion
        if (messageId) {
          row.dataset.messageId = messageId;
        }

        const column = document.createElement("div");
        column.className =
          "flex flex-col max-w-[80%] sm:max-w-[60%] gap-1";

        // Add profile picture for all messages
        const avatarDiv = document.createElement("div");
        avatarDiv.className = "h-7 w-7 sm:h-8 sm:w-8 rounded-full bg-gradient-to-br from-sky-500 to-sky-600 flex items-center justify-center text-white text-xs font-bold flex-shrink-0 cursor-pointer hover:opacity-80 transition-opacity overflow-hidden";
        avatarDiv.innerHTML = '<svg width="100%" height="100%" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>';
        avatarDiv.style.minWidth = "1.75rem";
        avatarDiv.style.minHeight = "1.75rem";

        // Load profile picture async (non-blocking) with lazy loading support for GIFs
        setTimeout(() => {
          fetchUserProfile(username).then(profile => {
            if (profile?.profilePic && avatarDiv.innerHTML.includes("svg")) {
              try {
                const img = document.createElement("img");
                const isGif = profile.profilePic.toLowerCase().includes('.gif');
                
                // Use lazy loading for GIFs and regular images
                img.className = "h-full w-full object-cover";
                img.onerror = () => {};
                
                if (isGif) {
                  // Lazy load GIF when visible
                  img.dataset.src = profile.profilePic;
                  const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                      if (entry.isIntersecting && img.dataset.src) {
                        img.src = img.dataset.src;
                        delete img.dataset.src;
                        observer.unobserve(img);
                      }
                    });
                  }, { rootMargin: "50px" });
                  observer.observe(img);
                } else {
                  img.src = profile.profilePic;
                }
                
                avatarDiv.innerHTML = "";
                avatarDiv.appendChild(img);
              } catch (e) {
                // Silently ignore, keep default
              }
            }
          }).catch(() => {
            // Silently ignore fetch errors
          });
        }, 0);

        // Click to view profile
        avatarDiv.addEventListener("click", () => {
          viewUserProfile(username);
        });

        row.appendChild(avatarDiv);

        // Add name label for received messages only; hide avatar for own messages
        if (!isMine) {

          const nameLabel = document.createElement("div");
          nameLabel.className =
            "text-[10px] sm:text-xs text-slate-400 px-3 font-medium cursor-pointer hover:text-slate-300 transition-colors";
          if (isOwnerMessage) {
            const ownerBadge = '<span class="ml-1 text-[9px] px-1.5 py-0.5 rounded-full bg-amber-500/15 text-amber-100 border border-amber-400/40">Owner</span>';
            nameLabel.innerHTML = '<span class="inline-flex items-center gap-1">' + '<span>' + username + '</span>' + ownerBadge + '</span>';
          } else if (isStaffMessage) {
            const staffBadge = '<span class="ml-1 text-[9px] px-1.5 py-0.5 rounded-full bg-sky-500/15 text-sky-100 border border-sky-400/40">Staff</span>';
            nameLabel.innerHTML = '<span class="inline-flex items-center gap-1">' + '<span>' + username + '</span>' + staffBadge + '</span>';
          } else {
            nameLabel.textContent = username;
          }
          nameLabel.addEventListener("click", () => {
            viewUserProfile(username);
          });
          column.appendChild(nameLabel);
        } else {
          // Hide avatar for own messages
          avatarDiv.style.display = "none";
        }

        // Add container for bubble + delete button
        const bubbleContainer = document.createElement("div");
        bubbleContainer.className = "relative group";

        const bubble = document.createElement("div");
        const textLength = (msg.text || "").length;
        const isSmallMessage = textLength <= 2;
        const padding = isSmallMessage ? "px-3 py-1.5" : "px-3 py-2";
        
        bubble.className = isMine
          ? `message-bubble-anim mine ${padding} sm:px-3 sm:py-2 rounded-2xl text-xs sm:text-sm leading-relaxed break-words shadow-sm bg-gradient-to-br from-sky-500 to-sky-600 text-white rounded-br-md font-medium shadow-md shadow-sky-500/20 inline-block max-w-full`
          : `message-bubble-anim ${padding} sm:px-3 sm:py-2 rounded-2xl text-xs sm:text-sm leading-relaxed break-words shadow-sm bg-slate-700/90 text-slate-50 rounded-bl-md border border-slate-600/50 backdrop-blur-sm inline-block max-w-full`;

        // Ensure bubble width hugs content for short messages
        bubble.style.display = "inline-block";
        bubble.style.maxWidth = "100%";

        // Add media if present (image or video)
        if (msg.media) {
          const mediaUrl = msg.media;
          const isVideo = mediaUrl.includes('.mp4') || mediaUrl.includes('video') || mediaUrl.includes('.mov') || mediaUrl.includes('.webm');
          const isGif = mediaUrl.toLowerCase().includes('.gif');
          
          if (isVideo) {
            const videoContainer = document.createElement("div");
            videoContainer.className = "relative rounded-lg overflow-hidden mb-2";
            videoContainer.style.maxWidth = "400px";
            
            const video = document.createElement("video");
            video.dataset.src = mediaUrl;
            video.controls = true;
            video.preload = "none";
            video.className = "w-full rounded-lg";
            video.style.maxHeight = "300px";
            video.style.display = "block";
            
            // Lazy load video when visible
            const observer = new IntersectionObserver((entries) => {
              entries.forEach(entry => {
                if (entry.isIntersecting && video.dataset.src) {
                  video.src = video.dataset.src;
                  video.preload = "metadata";
                  delete video.dataset.src;
                  observer.unobserve(video);
                }
              });
            }, { rootMargin: "100px" });
            observer.observe(video);
            
            // Scroll after video metadata loads
            video.addEventListener("loadedmetadata", () => {
              // Only scroll if we're at the bottom already
              if (messagesDiv.scrollTop >= messagesDiv.scrollHeight - messagesDiv.clientHeight - 100) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
              }
            });
            
            videoContainer.appendChild(video);
            bubble.appendChild(videoContainer);
          } else if (isGif) {
            const gifContainer = document.createElement("div");
            gifContainer.className = "relative rounded-lg overflow-hidden mb-2";
            gifContainer.style.maxWidth = "400px";
            
            const img = document.createElement("img");
            img.dataset.src = mediaUrl;
            img.className = "w-full rounded-lg cursor-pointer hover:opacity-90 transition-opacity";
            img.style.maxHeight = "300px";
            img.style.display = "block";
            img.style.objectFit = "contain";
            
            // Lazy load GIF when visible
            const observer = new IntersectionObserver((entries) => {
              entries.forEach(entry => {
                if (entry.isIntersecting && img.dataset.src) {
                  img.src = img.dataset.src;
                  delete img.dataset.src;
                  observer.unobserve(img);
                }
              });
            }, { rootMargin: "100px" });
            observer.observe(img);
            
            // GIF controls: loop continuously
            img.onload = () => {
              // Scroll only if at bottom
              if (messagesDiv.scrollTop >= messagesDiv.scrollHeight - messagesDiv.clientHeight - 100) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
              }
              
              // Force loop by reloading src when ended (for animated GIFs)
              setInterval(() => {
                const tempSrc = img.src;
                img.src = '';
                img.src = tempSrc;
              }, 10000); // Reload every 10 seconds to ensure loop
            };
            
            img.onclick = () => openImageViewer(mediaUrl);
            gifContainer.appendChild(img);
            bubble.appendChild(gifContainer);
          } else {
            const imgContainer = document.createElement("div");
            imgContainer.className = "relative rounded-lg overflow-hidden mb-2";
            imgContainer.style.maxWidth = "400px";
            
            const img = document.createElement("img");
            img.dataset.src = mediaUrl;
            img.className = "w-full rounded-lg cursor-pointer hover:opacity-90 transition-opacity";
            img.style.maxHeight = "300px";
            img.style.display = "block";
            img.style.objectFit = "contain";
            
            // Lazy load image when visible
            const observer = new IntersectionObserver((entries) => {
              entries.forEach(entry => {
                if (entry.isIntersecting && img.dataset.src) {
                  img.src = img.dataset.src;
                  delete img.dataset.src;
                  observer.unobserve(img);
                }
              });
            }, { rootMargin: "100px" });
            observer.observe(img);
            
            // Scroll after image loads (only if at bottom)
            img.onload = () => {
              if (messagesDiv.scrollTop >= messagesDiv.scrollHeight - messagesDiv.clientHeight - 100) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
              }
            };
            
            img.onclick = () => openImageViewer(mediaUrl);
            
            imgContainer.appendChild(img);
            bubble.appendChild(imgContainer);
          }
        }

        // Add text if present
        if (msg.text) {
          const textSpan = document.createElement("span");
          textSpan.className = "message-text-reveal inline-block";
          textSpan.textContent = msg.text;
          bubble.appendChild(textSpan);
        }
        
        bubbleContainer.appendChild(bubble);

        // Add delete button for own messages
        if (isMine && messageId) {
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "absolute -top-2 -right-2 w-6 h-6 rounded-full bg-slate-700 text-white opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center hover:bg-red-600 shadow-md";
          deleteBtn.innerHTML = "‚ãÆ";
          deleteBtn.title = "Message options";
          
          deleteBtn.addEventListener("click", () => {
            openDeleteMessageModal(messageId, msg.deleteToken);
          });
          
          bubbleContainer.appendChild(deleteBtn);
        }
        
        column.appendChild(bubbleContainer);

        row.appendChild(column);
        return row;
      }

      function renderMessage(msg, options = {}) {
        const { prepend = false, maintainScroll = false, messageId = null } = options;

        const row = createMessageRow(msg, messageId);

        if (prepend) {
          if (messagesDiv.firstChild) {
            messagesDiv.insertBefore(row, messagesDiv.firstChild);
          } else {
            messagesDiv.appendChild(row);
          }
        } else {
          messagesDiv.appendChild(row);
        }

        if (!maintainScroll) {
          // Check if already at bottom before scrolling
          const isAtBottom = messagesDiv.scrollHeight - messagesDiv.scrollTop - messagesDiv.clientHeight < 50;
          if (isAtBottom) {
            // Delay scroll to let images load
            setTimeout(() => {
              messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }, 200);
          }
        }
      }

      function renderMessageOnce(key, msg, options = {}) {
        if (!key) {
          console.warn("[messages] missing key for message", msg);
          renderMessage(msg, options);
          return;
        }
        if (seenMessageKeys.has(key)) return;
        
        // Filter out messages from blocked users
        if (isMessageFromBlockedUser(msg)) {
          seenMessageKeys.add(key); // Mark as seen but don't render
          return;
        }
        
        seenMessageKeys.add(key);
        renderMessage(msg, { ...options, messageId: key });
      }

      function removeMessageById(messageId) {
        if (!messageId) return;
        const rows = messagesDiv.querySelectorAll("[data-message-id]");
        rows.forEach((row) => {
          if (row.dataset.messageId === messageId) {
            row.remove();
          }
        });
        seenMessageKeys.delete(messageId);
      }

      function previewText(text, max = 80) {
        if (!text) return "";
        const t = text.toString();
        return t.length > max ? t.slice(0, max) + "‚Ä¶" : t;
      }

      // Batch render messages for better performance
      function batchRenderMessages(messages, options = {}) {
        const fragment = document.createDocumentFragment();
        let newMessagesCount = 0;

        messages.forEach(({ key, msg }) => {
          if (key && seenMessageKeys.has(key)) return;
          
          // Filter out messages from blocked users
          if (isMessageFromBlockedUser(msg)) {
            if (key) seenMessageKeys.add(key); // Mark as seen but don't render
            return;
          }
          
          if (key) seenMessageKeys.add(key);

          const row = createMessageRow(msg, key);
          if (options.prepend) {
            fragment.insertBefore(row, fragment.firstChild);
          } else {
            fragment.appendChild(row);
          }
          newMessagesCount++;
        });

        if (newMessagesCount > 0) {
          // Use requestAnimationFrame for smoother rendering
          requestAnimationFrame(() => {
            if (options.prepend && messagesDiv.firstChild) {
              messagesDiv.insertBefore(fragment, messagesDiv.firstChild);
            } else {
              messagesDiv.appendChild(fragment);
            }

            if (!options.maintainScroll) {
              messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
          });
        }
      }

      // --- INFINITE SCROLL HELPERS ---
      function onMessagesScroll() {
        if (allHistoryLoaded || isLoadingOlder) return;
        // When user is near top (~5 messages above), load older
        const threshold = 120; // px from top, tweak if you want
        if (messagesDiv.scrollTop <= threshold) {
          loadOlderMessages();
        }
      }

      function attachScrollListener() {
        if (scrollListenerAttached) return;
        messagesDiv.addEventListener("scroll", onMessagesScroll);
        scrollListenerAttached = true;
      }

      function detachScrollListener() {
        if (!scrollListenerAttached) return;
        messagesDiv.removeEventListener("scroll", onMessagesScroll);
        scrollListenerAttached = false;
      }

      function loadOlderMessages() {
        if (isLoadingOlder) return;
        if (oldestTime === null) return;
        isLoadingOlder = true;
        console.log("[messages] loading older messages before time =", oldestTime);

        const prevScrollHeight = messagesDiv.scrollHeight;
        const prevScrollTop = messagesDiv.scrollTop;

        const baseRef = db.ref("messages").orderByChild("time");

        baseRef
          .endAt(oldestTime - 1)
          .limitToLast(PAGE_SIZE)
          .once(
            "value",
            (snap) => {
              const msgs = [];
              snap.forEach((child) => {
                msgs.push({ key: child.key, msg: child.val() || {} });
              });

              if (msgs.length === 0) {
                console.log("[messages] no older messages, all history loaded");
                allHistoryLoaded = true;
                isLoadingOlder = false;
                return;
              }

              // Update time range
              msgs.forEach(({ key, msg }) => {
                const t = msg.time || 0;
                if (oldestTime === null || t < oldestTime) {
                  oldestTime = t;
                }
              });

              // Batch render for performance
              batchRenderMessages(msgs, {
                prepend: true,
                maintainScroll: true,
              });

              const newScrollHeight = messagesDiv.scrollHeight;
              const addedHeight = newScrollHeight - prevScrollHeight;
              messagesDiv.scrollTop = prevScrollTop + addedHeight;

              console.log(
                "[messages] loaded older page, count =",
                msgs.length,
                "oldestTime now =",
                oldestTime
              );

              if (msgs.length < PAGE_SIZE) {
                allHistoryLoaded = true;
              }

              isLoadingOlder = false;
            },
            (error) => {
              console.error("[messages] error loading older:", error);
              isLoadingOlder = false;
            }
          );
      }

      async function startMessagesListener() {
        console.log("[messages] startMessagesListener called");
        stopMessagesListener();
        seenMessageKeys.clear();
        messagesDiv.innerHTML = "";

        oldestTime = null;
        newestTime = null;
        allHistoryLoaded = false;
        isLoadingOlder = false;

        // Load blocked users cache first
        await loadBlockedUsersCache();

        try {
          const baseRef = db.ref("messages").orderByChild("time");
          const initialQuery = baseRef.limitToLast(PAGE_SIZE);

          initialQuery.once(
            "value",
            (snap) => {
              const msgs = [];
              snap.forEach((child) => {
                msgs.push({ key: child.key, msg: child.val() || {} });
              });

              const count = msgs.length;
              console.log("[messages] initial load snapshot, count =", count);

              // Calculate time range
              msgs.forEach(({ key, msg }) => {
                const t = msg.time || 0;
                if (oldestTime === null || t < oldestTime) {
                  oldestTime = t;
                }
                if (newestTime === null || t > newestTime) {
                  newestTime = t;
                }
              });

              // Batch render all messages at once
              batchRenderMessages(msgs, { maintainScroll: true });

              // After initial render, jump to bottom (wait for images to load)
              const scrollToBottom = () => {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                console.log("[scroll] scrolled to bottom, scrollHeight:", messagesDiv.scrollHeight);
              };

              // Try multiple times to ensure we catch all image loads
              setTimeout(scrollToBottom, 300);
              setTimeout(scrollToBottom, 800);
              setTimeout(scrollToBottom, 1500);

              // Hide loading screen after messages are loaded
              loadingScreen.classList.add("hidden");

              if (count < PAGE_SIZE) {
                allHistoryLoaded = true;
              }

              // Attach scroll listener only after we have some messages
              attachScrollListener();

              // --- REALTIME LISTENER FOR NEW MESSAGES ---
              if (messagesRef && messagesListener) {
                messagesRef.off("child_added", messagesListener);
              }

              if (newestTime !== null) {
                messagesRef = baseRef.startAt(newestTime + 1);
              } else {
                messagesRef = baseRef;
              }

              messagesListener = (snap) => {
                const msg = snap.val() || {};
                const key = snap.key;
                const t = msg.time || 0;

                if (newestTime === null || t > newestTime) {
                  newestTime = t;
                }

                // Notify if a friend posts in global chat
                const chatHidden = chatInterface.classList.contains("hidden");
                const dmOpen = dmModal.classList.contains("modal-open");
                const pageHidden = document.hidden;
                const shouldNotifyFriendGlobal = chatHidden || dmOpen || pageHidden;
                if (
                  msg.userId &&
                  friendsCache.has(msg.userId) &&
                  msg.userId !== currentUserId &&
                  shouldNotifyFriendGlobal
                ) {
                  addNotification(
                    "Friend in Global Chat",
                    `${msg.user || "Friend"}: ${previewText(msg.text || "(no text)", 80)}`,
                    { threadId: null }
                  );
                }
                renderMessageOnce(key, msg);
              };

              messagesRef.on(
                "child_added",
                messagesListener,
                (error) => {
                  console.error("[messages] listener error:", error);
                }
              );

              // Listen for deletions to remove messages live
              if (messagesRemoveRef && messagesRemoveListener) {
                messagesRemoveRef.off("child_removed", messagesRemoveListener);
              }
              messagesRemoveRef = db.ref("messages");
              messagesRemoveListener = (snap) => {
                const removedId = snap.key;
                removeMessageById(removedId);
              };
              messagesRemoveRef.on(
                "child_removed",
                messagesRemoveListener,
                (error) => console.error("[messages] remove listener error:", error)
              );
            },
            (error) => {
              console.error("[messages] error during initial load:", error);
              loadingScreen.classList.add("hidden");
            }
          );
        } catch (err) {
          console.error("[messages] startMessagesListener crashed:", err);
          loadingScreen.classList.add("hidden");
        }
      }

      function stopMessagesListener() {
        console.log("[messages] stopMessagesListener called");
        try {
          if (messagesRef && messagesListener) {
            messagesRef.off("child_added", messagesListener);
          }
          if (messagesRemoveRef && messagesRemoveListener) {
            messagesRemoveRef.off("child_removed", messagesRemoveListener);
          }
        } catch (err) {
          console.error("[messages] error while stopping listener:", err);
        }
        messagesRef = null;
        messagesListener = null;
        messagesRemoveRef = null;
        messagesRemoveListener = null;
        seenMessageKeys.clear();

        detachScrollListener();

        oldestTime = null;
        newestTime = null;
        allHistoryLoaded = false;
        isLoadingOlder = false;
      }

      // --- TYPING STATUS HELPERS ---
      function setTyping(isTyping) {
        if (!currentUserId) {
          console.debug("[typing] setTyping called but no userId");
          return;
        }
        const ref = db.ref("typingStatus/" + currentUserId);
        const name = currentUsername || "User";
        console.log("[typing] setting typing status:", isTyping, "for", currentUserId);
        return ref.set({
          username: name,
          typing: isTyping,
          ts: firebase.database.ServerValue.TIMESTAMP,
        }).catch((err) => {
          // Detailed logging for typing status errors
          if (err.message?.includes("permission_denied")) {
            console.warn("[typing] permission denied on /typingStatus/" + currentUserId + " - this is OK, typing indicators may not work");
          } else {
            logDetailedError("setTyping", err, { userId: currentUserId, isTyping });
          }
        });
      }

      function handleTypingSnapshot(snap) {
        const data = snap.val() || {};
        const typingUsers = [];

        for (const uid in data) {
          if (!Object.prototype.hasOwnProperty.call(data, uid)) continue;
          if (uid === currentUserId) continue; // don't show yourself

          const entry = data[uid];
          if (entry && entry.typing) {
            const name = entry.username || "Someone";
            typingUsers.push(name);
          }
        }

        let text = "";
        if (typingUsers.length === 1) {
          text = typingUsers[0] + " is typing‚Ä¶";
        } else if (typingUsers.length === 2) {
          text = typingUsers[0] + " and " + typingUsers[1] + " are typing‚Ä¶";
        } else if (typingUsers.length === 3) {
          text = typingUsers[0] + ", " + typingUsers[1] + ", and " + typingUsers[2] + " are typing‚Ä¶";
        } else if (typingUsers.length > 3) {
          text = "Several people are typing‚Ä¶";
        }

        lastTypingText = text;
        updateStatusBar();
      }

      function startTypingListener() {
        if (typingListenerAttached) return;
        console.log("[typing] attaching typingStatus listener");
        
        db.ref("typingStatus").on(
          "value",
          handleTypingSnapshot,
          (err) => {
            console.error("[typing] listener error:", err);
          }
        );
        typingListenerAttached = true;

        // Clean up stale typing status every 5 seconds
        if (!typingCleanupInterval) {
          typingCleanupInterval = setInterval(() => {
            const now = Date.now();
            db.ref("typingStatus").once("value", (snap) => {
              const data = snap.val() || {};
              const updates = {};
              
              for (const uid in data) {
                if (!Object.prototype.hasOwnProperty.call(data, uid)) continue;
                const entry = data[uid];
                // Remove if older than 10 seconds
                if (entry && entry.ts && (now - entry.ts) > 10000) {
                  updates[uid] = null;
                }
              }
              
              if (Object.keys(updates).length > 0) {
                db.ref("typingStatus").update(updates).catch(err => {
                  // Silently ignore permission errors during cleanup
                  if (!err.message?.includes("PERMISSION_DENIED")) {
                    console.warn("[typing] cleanup error:", err);
                  }
                });
              }
            });
          }, TYPING_CLEANUP_INTERVAL);
        }
      }

      function stopTypingListener() {
        if (!typingListenerAttached) return;
        console.log("[typing] detaching typingStatus listener");
        db.ref("typingStatus").off("value", handleTypingSnapshot);
        typingListenerAttached = false;
        lastTypingText = "";
        updateStatusBar();

        // Clear cleanup interval
        if (typingCleanupInterval) {
          clearInterval(typingCleanupInterval);
          typingCleanupInterval = null;
        }
      }

      // Typing on input with throttling
      let lastTypingUpdate = 0;
      const TYPING_THROTTLE = 1000; // Only update once per second
      
      msgInput.addEventListener("input", () => {
        if (!currentUserId) return;

        const now = Date.now();
        // Throttle typing updates to reduce database writes
        if (now - lastTypingUpdate > TYPING_THROTTLE) {
          setTyping(true);
          lastTypingUpdate = now;
        }

        // Auto stop after 1.5s of no input
        if (typingTimeoutId) {
          clearTimeout(typingTimeoutId);
        }
        typingTimeoutId = setTimeout(() => {
          setTyping(false);
        }, 1500);
      });

      // Auto-handle already logged-in users on page load
      auth.onAuthStateChanged(async (user) => {
        console.log(
          "[auth] onAuthStateChanged user =",
          user ? user.uid : null
        );

        if (user) {
          try {
            // Check if user is banned IMMEDIATELY
            const banSnap = await db.ref("bannedUsers/" + user.uid).once("value");
            if (banSnap.exists()) {
              const banData = banSnap.val();
              const now = Date.now();
              
              console.log("[auth] user has ban entry:", banData);
              
              // Check if it's a temporary ban that has expired
              if (banData.until && banData.until <= now) {
                // Temporary ban has expired, remove ban entry and allow login
                clearExpiredBan(user.uid, banData);
                console.log("[auth] temporary ban has expired, allowing login");
              } else {
                // Either permanent ban or active temporary ban
                console.log("[auth] user is banned, showing popup and signing out");

                // Reuse existing ban popup UI instead of alert
                const banPopup = document.getElementById("banPopup");
                const banReason = document.getElementById("banReason");
                if (banPopup && banReason) {
                  banReason.textContent = "Reason: " + (banData.reason || "Permanent ban");
                  banPopup.classList.remove("hidden");
                }

                setTimeout(() => {
                  auth.signOut();
                }, 3000);
                return;
              }
            }

            currentUserId = user.uid;
            
            // Load cleared notifications from localStorage
            loadClearedNotifications();

            // Get username from DB (ONE PLACE)
            currentUsername = await fetchUsername(
              user.uid,
              user.email || null
            );
            
            if (!currentUsername) {
              throw new Error("Could not get username");
            }
            
            updateChatUserLabel(currentUsername);

            // Auto-ensure paths exist
            try {
              await ensureUsernamePath(user.uid, currentUsername);
              await ensureUserProfilePath(user.uid);
              await ensureFriendRequestsPaths(user.uid);
              await ensureFriendsList(user.uid);
            } catch (e) {
              console.warn("[auth] could not ensure paths:", e);
              // Continue anyway
            }

            loginForm.classList.add("hidden");
            registerForm.classList.add("hidden");
            chatInterface.classList.remove("hidden");
            
            // Ensure messages container is always visible
            if (messagesDiv) {
              messagesDiv.style.display = '';
            }
            
            // Only show loading screen if messages container is empty
            if (!messagesDiv || messagesDiv.children.length === 0) {
              loadingScreen.classList.remove("hidden");
            }
            
            // Show notification bell when logged in
            notifBellBtn.classList.remove("hidden");
            
            // Request notification permission
            if ("Notification" in window && Notification.permission === "default") {
              Notification.requestPermission();
            }

            console.log("[auth] starting messages listener from auth state change");
            startMessagesListener();
            startTypingListener();
            await loadFriendsCache();

            // Moderation hooks
            checkAdmin();
            watchBanStatus(user.uid);
            watchMuteStatus(user.uid);
            watchWarnings(user.uid);
            setupWarnModal();
            setupMuteModal();
            setupBanModal();
            
            // Start DM inbox listener for notifications
            await loadDmInbox();
            
            // Wait a moment for initial notifications to load, then verify
            setTimeout(() => {
              verifyNotificationsLoaded();
            }, 500);

            // Load user settings (theme, message size) from Firebase
            const settings = await loadUserSettings();
            setActiveThemeButton(settings.theme);
            applyTheme(settings.theme, false);
            setActiveSizeButton(settings.messageSize);
            applyMessageSize(settings.messageSize, false);
            if (fastModeToggle) fastModeToggle.checked = settings.fastMode === true;
            applyFastMode(settings.fastMode === true, false);
            if (fastModeToggle) {
              fastModeToggle.checked = settings.fastMode === true;
            }
            applyFastMode(settings.fastMode === true, false);
          } catch (err) {
            console.error("[auth] error in onAuthStateChanged:", err);
            // Show error and sign out
            try {
              await auth.signOut();
            } catch (e) {
              console.warn("[auth] error signing out:", e);
            }
            alert("Error loading your profile. Please log in again.");
          }
        } else {
          console.log(
            "[auth] user is null, stopping listeners and showing login"
          );

          stopMessagesListener();
          stopTypingListener();

          currentUserId = null;
          currentUsername = null;
          messagesDiv.innerHTML = "";
          friendsCache.clear();
          clearedNotificationThreads.clear();
          dmLastSeenByThread = {};
          dmInboxInitialLoaded = false;
          detachModerationListeners();
          clearNotifications();
          activeDMThread = null;
          activeDMTarget = null;
          clearDmMessages();
          dmConversationList.innerHTML = "";
          detachDmMessagesListener();
          detachDmInboxListener();
          dmModal.classList.add("modal-closed");
          dmModal.classList.remove("modal-open");

          chatInterface.classList.add("hidden");
          loginForm.classList.remove("hidden");
          // Hide loading screen if not logged in
          loadingScreen.classList.add("hidden");
          
          // Hide notification bell when not logged in
          notifBellBtn.classList.add("hidden");
          
          updateChatUserLabel("");
        }
      });

      // Logout
      logoutBtn.onclick = async () => {
        console.log("[logout] clicked");
        logoutBtn.disabled = true;
        logoutBtn.textContent = "Logging out...";

        try {
          // Try to clear typing status before leaving
          try {
            if (currentUserId) {
              await db.ref("typingStatus/" + currentUserId).remove();
              console.log("[logout] cleared typing status");
            }
          } catch (e) {
            console.warn("[logout] could not clear typing status:", e);
          }

          // Stop listeners
          stopMessagesListener();
          stopTypingListener();

          // Sign out
          await auth.signOut();
          console.log("[logout] signOut complete");

          // Clear UI
          msgInput.value = "";
          loginPasswordInput.value = "";
          clearLoginMessages();
          loginUsernameInput.value = "";
        } catch (err) {
          console.error("[logout] error during logout:", err);
          alert("Error logging out. Try refreshing the page.");
        } finally {
          logoutBtn.disabled = false;
          logoutBtn.textContent = "Logout";
        }
      };

      // Send a message (shared logic) + local rate-limit + server rules
      function sendMessage() {
        const text = msgInput.value.trim();
        if (text === "" && !pendingMediaUrl) return;

        const userObj = auth.currentUser;
        if (!userObj) {
          console.warn("[send] tried to send while not logged in");
          currentWarningText = "Not logged in. Please refresh and log in again.";
          updateStatusBar();
          msgInput.value = "";
          setTimeout(() => {
            currentWarningText = "";
            updateStatusBar();
          }, 3000);
          return;
        }
        
        if (!currentUsername) {
          console.warn("[send] no username set");
          currentWarningText = "Username not loaded. Please refresh.";
          updateStatusBar();
          setTimeout(() => {
            currentWarningText = "";
            updateStatusBar();
          }, 3000);
          return;
        }

        if (isMuted) {
          alert("You are muted and cannot send messages right now.");
          return;
        }

        // ‚úÖ Local send cooldowns (match server rules: 0.5s text, 1s media)
        const now = Date.now();
        const isMedia = !!pendingMediaUrl;
        const cooldown = isMedia ? MEDIA_COOLDOWN_MS : TEXT_COOLDOWN_MS;
        if (now - lastSentTime < cooldown) {
          showRateLimitWarning();
          return;
        }
        lastSentTime = now;

        // Bad-word filter (client-side guard; server rules should also block)
        if (text && badWordPattern.test(text)) {
          currentWarningText = "Message blocked: language not allowed.";
          updateStatusBar();
          setTimeout(() => {
            currentWarningText = "";
            updateStatusBar();
          }, 2500);
          return;
        }

        const username = currentUsername;

        console.log("[send] sending message", {
          username,
          text,
          hasMedia: !!pendingMediaUrl,
          userId: userObj.uid,
        });

        const uid = userObj.uid;

        // Add visual feedback to send button
        const originalBtnText = sendBtn.innerHTML;
        sendBtn.innerHTML = '<span class="animate-pulse">‚úì</span>';
        sendBtn.disabled = true;

        // Build message object
        const messageData = {
          user: username,
          userId: uid,
          text: text,
          time: firebase.database.ServerValue.TIMESTAMP,
        };

        // Add media if present
        if (pendingMediaUrl) {
          messageData.media = pendingMediaUrl;
          messageData.deleteToken = pendingMediaToken;
        }

        // Push the message + update rate-limit timestamps atomically
        const newMsgKey = db.ref("messages").push().key;
        const updates = {};
        updates["messages/" + newMsgKey] = messageData;
        updates["userLastMessageTime/" + uid] = firebase.database.ServerValue.TIMESTAMP;
        if (messageData.media) {
          updates["userLastMediaTime/" + uid] = firebase.database.ServerValue.TIMESTAMP;
        }

        db.ref()
          .update(updates)
          .then(() => {
            // Only clear input when message + timestamp both succeed
            msgInput.value = "";
            
            // Clear media preview
            if (pendingMediaUrl) {
              pendingMediaUrl = null;
              pendingMediaToken = null;
              mediaPreview.classList.add("hidden");
              mediaPreviewContent.innerHTML = "";
            }
            
            // Stop typing once message is sent
            setTyping(false);
            
            // Reset button after 300ms
            setTimeout(() => {
              sendBtn.innerHTML = originalBtnText;
              sendBtn.disabled = false;
            }, 300);
          })
          .catch((error) => {
            console.error("[send] error sending message:", error);
            
            let errorMsg = "Failed to send message";
            if (error.code === "PERMISSION_DENIED") {
              errorMsg = "Message blocked (rate limit or permissions)";
              showRateLimitWarning();
            } else if (error.message?.includes("permission")) {
              errorMsg = "Permission denied. Check Firebase rules.";
            } else if (error.message?.includes("network")) {
              errorMsg = "Network error. Check your connection.";
            }
            
            currentWarningText = errorMsg;
            updateStatusBar();
            
            // Reset button on error
            setTimeout(() => {
              sendBtn.innerHTML = originalBtnText;
              sendBtn.disabled = false;
              currentWarningText = "";
              updateStatusBar();
            }, 3000);
          });
      }

      // Form submit = send message (works with Enter / Return everywhere)
      messageForm.addEventListener("submit", (e) => {
        e.preventDefault();
        sendMessage();
      });

      // Media upload handlers
      const mediaUploadBtn = document.getElementById("mediaUploadBtn");
      const mediaInput = document.getElementById("imageInput");
      const imageInput = mediaInput;

      // ImageKit upload with lightweight auth tag
      async function uploadToImageKit(file) {
        // Cloudflare Worker URL
        const workerUrl = "https://chatra.modmojheh.workers.dev";

        if (!workerUrl || workerUrl.includes("your-worker-subdomain")) {
          const err = "Cloudflare Worker URL not configured. Update the workerUrl in the code.";
          console.error("[imagekit] configuration error:", err);
          throw new Error(err);
        }

        const formData = new FormData();
        formData.append("file", file);

        console.log("[imagekit] starting upload to worker:", workerUrl);
        console.log("[imagekit] file:", {
          name: file.name,
          size: file.size,
          type: file.type,
        });

        try {
          const startTime = Date.now();

          const res = await fetch(workerUrl, {
            method: "POST",
            body: formData,
          });

          const duration = Date.now() - startTime;
          console.log("[imagekit] response received after", duration, "ms, status:", res.status);

          let data;
          try {
            data = await res.json();
          } catch (jsonErr) {
            console.error("[imagekit] failed to parse response as JSON:", jsonErr);
            const text = await res.text();
            console.error("[imagekit] response text:", text);
            throw new Error(`Invalid response from worker: ${res.status} ${text.substring(0, 100)}`);
          }

          if (!res.ok) {
            const errorMsg = data?.error || `HTTP ${res.status}`;
            console.error("[imagekit] worker returned error:", {
              status: res.status,
              error: errorMsg,
              data: data,
            });
            throw new Error(`Upload failed: ${errorMsg}`);
          }

          if (!data?.url) {
            console.error("[imagekit] success response missing URL:", data);
            throw new Error(data?.error || "Upload failed: no URL returned from worker");
          }

          console.log("[imagekit] upload success:", {
            url: data.url,
            fileId: data.fileId,
            duration: duration,
          });

          return data.url;
        } catch (err) {
          const errorDetails = {
            message: err.message,
            name: err.name,
            stack: err.stack,
            file: file.name,
            fileSize: file.size,
            workerUrl: workerUrl,
          };

          console.error("[imagekit] upload failed with detailed error:", errorDetails);

          // Provide user-friendly error messages
          let userMessage = "Upload failed";
          if (err.message.includes("Failed to fetch")) {
            userMessage = "Cannot reach upload server. Check your internet connection or worker URL.";
          } else if (err.message.includes("not configured")) {
            userMessage = "Upload not configured. Contact support.";
          } else if (err.message.includes("HTTP 401")) {
            userMessage = "Upload authentication failed. Check ImageKit credentials.";
          } else if (err.message.includes("HTTP 403")) {
            userMessage = "Upload permission denied. Check ImageKit settings.";
          } else if (err.message.includes("HTTP 500")) {
            userMessage = "Server error. Please try again later.";
          } else if (err.message.includes("HTTP 413")) {
            userMessage = "File too large. Maximum size is 25MB.";
          } else {
            userMessage = err.message;
          }

          console.error("[imagekit] user-friendly message:", userMessage);
          throw new Error(userMessage);
        }
      }

      // Persist per-user upload cooldown timestamps
      function storeUploadTime() {
        const uid = firebase.auth().currentUser?.uid;
        if (!uid) return;
        firebase.database().ref("uploadTimes/" + uid).set(Date.now()).catch(() => {});
      }

      async function canUpload() {
        const uid = firebase.auth().currentUser?.uid;
        if (!uid) return false;
        const snap = await firebase.database().ref("uploadTimes/" + uid).get();
        if (!snap.exists()) return true;
        return Date.now() - snap.val() > 5000; // 5s cooldown
      }

      // Basic image compression helper
      async function compressImage(file, quality = 0.7) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const reader = new FileReader();

          reader.onload = () => {
            img.onload = () => {
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");
              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);
              canvas.toBlob(
                (blob) => {
                  if (!blob) {
                    reject(new Error("Compression failed"));
                    return;
                  }
                  const compressed = new File([blob], file.name || "upload.jpg", {
                    type: blob.type || "image/jpeg",
                    lastModified: Date.now(),
                  });
                  resolve(compressed);
                },
                "image/jpeg",
                quality
              );
            };
            img.onerror = () => reject(new Error("Could not load image for compression"));
            img.src = reader.result;
          };

          reader.onerror = () => reject(new Error("Failed to read file"));
          reader.readAsDataURL(file);
        });
      }

      async function prepareFileForUpload(file) {
        const type = (file?.type || "").toLowerCase();

        if (type.includes("gif")) {
          console.log("[upload] GIF detected ‚Äì skipping compression.");
          return file;
        }

        if (type.includes("video")) {
          console.log("[upload] video detected ‚Äì skipping compression.");
          return file;
        }

        console.log("[upload] compressing image...");
        return await compressImage(file, 0.7);
      }

      async function sendImageMessage(file) {
        const userObj = auth.currentUser;
        if (!userObj || !currentUsername) return;
        if (!(await canUpload())) {
          alert("Slow down! Wait a few seconds.");
          return;
        }

        const processed = await prepareFileForUpload(file);
        const url = await uploadToImageKit(processed);
        storeUploadTime();

        const messageData = {
          user: currentUsername,
          userId: userObj.uid,
          media: url,
          time: firebase.database.ServerValue.TIMESTAMP,
        };

        return db.ref("messages").push(messageData);
      }

      mediaUploadBtn.addEventListener("click", () => {
        mediaInput.click();
      });

      // Global variables for pending media
      let pendingMediaUrl = null;
      let pendingMediaToken = null;
      const mediaPreview = document.getElementById("mediaPreview");
      const mediaPreviewContent = document.getElementById("mediaPreviewContent");
      const cancelMediaBtn = document.getElementById("cancelMediaBtn");

      mediaInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const userObj = auth.currentUser;
        if (!userObj) {
          alert("Please log in to send media");
          return;
        }

        if (!(await canUpload())) {
          alert("Slow down! Wait a few seconds.");
          mediaInput.value = "";
          return;
        }

        try {
          // Show uploading state
          mediaUploadBtn.disabled = true;
          mediaUploadBtn.innerHTML = '<svg class="animate-spin" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"/><path d="M12 2a10 10 0 0 1 10 10" stroke-opacity="0.75"/></svg>';

          const processedFile = await prepareFileForUpload(file);
          const imageKitUrl = await uploadToImageKit(processedFile);
          storeUploadTime();

          pendingMediaUrl = imageKitUrl;
          pendingMediaToken = null;

          // Show preview
          mediaPreviewContent.innerHTML = "";
          const isVideo = file.type.includes('video');
          
          if (isVideo) {
            const video = document.createElement("video");
            video.src = pendingMediaUrl;
            video.controls = true;
            video.className = "max-h-20 rounded-lg";
            mediaPreviewContent.appendChild(video);
          } else {
            const img = document.createElement("img");
            img.src = pendingMediaUrl;
            img.className = "max-h-20 rounded-lg";
            mediaPreviewContent.appendChild(img);
          }

          mediaPreview.classList.remove("hidden");
          msgInput.focus();

          console.log("[media] uploaded, ready to send:", pendingMediaUrl);

          // Reset button
          mediaUploadBtn.disabled = false;
          mediaUploadBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-400"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>';
          
          // Clear input
          mediaInput.value = "";
        } catch (err) {
          console.error("[media] error uploading:", err);
          alert("Error uploading media: " + err.message);
          
          // Reset button
          mediaUploadBtn.disabled = false;
          mediaUploadBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-400"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>';
          mediaInput.value = "";
        }
      });

      // Cancel media button
      cancelMediaBtn.addEventListener("click", async () => {
        // Delete the uploaded file from Cloudinary if it exists (legacy uploads only)
        if (pendingMediaToken) {
          try {
            console.log("[media] deleting uploaded file from Cloudinary");
            await deleteFromCloudinary(pendingMediaToken);
          } catch (err) {
            console.error("[media] error deleting from Cloudinary:", err);
          }
        }
        
        pendingMediaUrl = null;
        pendingMediaToken = null;
        mediaPreview.classList.add("hidden");
        mediaPreviewContent.innerHTML = "";
      });

      // ===== SETTINGS MENU & MODALS =====
      const menuToggle = document.getElementById("menuToggle");
      const settingsModal = document.getElementById("settingsModal");
      const profileModal = document.getElementById("profileModal");
      const viewProfileModal = document.getElementById("viewProfileModal");
      const settingsCloseBtn = document.getElementById("settingsCloseBtn");
      const profileCloseBtn = document.getElementById("profileCloseBtn");
      const saveProfileBtn = document.getElementById("saveProfileBtn");
      const uploadPicBtn = document.getElementById("uploadPicBtn");
      const viewProfileCloseBtn = document.getElementById("viewProfileCloseBtn");
      const viewProfileCloseBtn2 = document.getElementById("viewProfileCloseBtn2");
      const viewProfilePic = document.getElementById("viewProfilePic");
      const viewProfileName = document.getElementById("viewProfileName");
      const viewProfileBio = document.getElementById("viewProfileBio");
      const profilePicInput = document.getElementById("profilePicInput");
      const profileBio = document.getElementById("profileBio");
      const profileUsername = document.getElementById("profileUsername");
      const profilePicPreview = document.getElementById("profilePicPreview");

      let currentUserData = {};

      // Side Panel Elements
      const sidePanel = document.getElementById("sidePanel");
      const sidePanelOverlay = document.getElementById("sidePanelOverlay");
      const sidePanelClose = document.getElementById("sidePanelClose");
      const sidePanelUsername = document.getElementById("sidePanelUsername");
      const sidePanelProfile = document.getElementById("sidePanelProfile");
      const sidePanelSettings = document.getElementById("sidePanelSettings");
      const sidePanelPrivacy = document.getElementById("sidePanelPrivacy");
      const sidePanelFriendRequests = document.getElementById("sidePanelFriendRequests");
      const sidePanelFriends = document.getElementById("sidePanelFriends");
      const sidePanelDMs = document.getElementById("sidePanelDMs");
      const sidePanelDMBadge = document.getElementById("sidePanelDMBadge");
      const sidePanelBlocked = document.getElementById("sidePanelBlocked");
      const sidePanelFriendBadge = document.getElementById("sidePanelFriendBadge");

      // DM Elements
      const dmModal = document.getElementById("dmModal");
      const dmCloseBtn = document.getElementById("dmCloseBtn");
      const dmUserSearch = document.getElementById("dmUserSearch");
      const dmStartBtn = document.getElementById("dmStartBtn");
      const dmConversationList = document.getElementById("dmConversationList");
      const dmMessages = document.getElementById("dmMessages");
      const dmForm = document.getElementById("dmForm");
      const dmInput = document.getElementById("dmInput");
      const dmSendBtn = document.getElementById("dmSendBtn");
      const dmActiveUser = document.getElementById("dmActiveUser");
      const dmError = document.getElementById("dmError");
      const dmBlockBtn = document.getElementById("dmBlockBtn");

      // Notifications
      const notifBellBtn = document.getElementById("notifBellBtn");
      const notifBellBadge = document.getElementById("notifBellBadge");
      const notifModal = document.getElementById("notifModal");
      const notifCloseBtn = document.getElementById("notifCloseBtn");
      const notifClearBtn = document.getElementById("notifClearBtn");
      const notifList = document.getElementById("notifList");

      // Blocked Users Elements
      const blockedUsersModal = document.getElementById("blockedUsersModal");
      const blockedUsersCloseBtn = document.getElementById("blockedUsersCloseBtn");
      const blockedUsersList = document.getElementById("blockedUsersList");
      const noBlockedUsersMsg = document.getElementById("noBlockedUsersMsg");
      const blockUserBtn = document.getElementById("blockUserBtn");

      // User Search Elements
      const searchUsersInput = document.getElementById("searchUsersInput");
      const searchResults = document.getElementById("searchResults");

      // Privacy Settings Elements
      const privacySettingsModal = document.getElementById("privacySettingsModal");
      const privacySettingsCloseBtn = document.getElementById("privacySettingsCloseBtn");
      const allowFriendRequestsToggle = document.getElementById("allowFriendRequestsToggle");
      const allowDMsToggle = document.getElementById("allowDMsToggle");
      const savePrivacyBtn = document.getElementById("savePrivacyBtn");

      // Open/Close Side Panel
      function openSidePanel() {
        sidePanel.style.transform = "translateX(0)";
        sidePanelOverlay.classList.remove("hidden");
        if (currentUsername) {
          sidePanelUsername.textContent = currentUsername;
        }
      }

      function closeSidePanel() {
        sidePanel.style.transform = "translateX(-100%)";
        sidePanelOverlay.classList.add("hidden");
      }

      menuToggle.addEventListener("click", openSidePanel);
      sidePanelClose.addEventListener("click", closeSidePanel);
      sidePanelOverlay.addEventListener("click", closeSidePanel);

      // Close settings modal
      settingsCloseBtn.addEventListener("click", () => {
        settingsModal.classList.remove("modal-open");
        settingsModal.classList.add("modal-closed");
      });

      settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
          settingsModal.classList.remove("modal-open");
          settingsModal.classList.add("modal-closed");
        }
      });

      // Blocked Users Modal
      blockedUsersCloseBtn.addEventListener("click", () => {
        blockedUsersModal.classList.remove("modal-open");
        blockedUsersModal.classList.add("modal-closed");
      });

      blockedUsersModal.addEventListener("click", (e) => {
        if (e.target === blockedUsersModal) {
          blockedUsersModal.classList.remove("modal-open");
          blockedUsersModal.classList.add("modal-closed");
        }
      });

      // Privacy Settings Modal
      privacySettingsCloseBtn.addEventListener("click", () => {
        privacySettingsModal.classList.remove("modal-open");
        privacySettingsModal.classList.add("modal-closed");
      });

      privacySettingsModal.addEventListener("click", (e) => {
        if (e.target === privacySettingsModal) {
          privacySettingsModal.classList.remove("modal-open");
          privacySettingsModal.classList.add("modal-closed");
        }
      });

      notifBellBtn.addEventListener("click", async () => {
        await clearNotifications();
        renderNotificationHistory();
        notifModal.classList.remove("modal-closed");
        notifModal.classList.add("modal-open");
      });

      notifCloseBtn.addEventListener("click", () => {
        notifModal.classList.remove("modal-open");
        notifModal.classList.add("modal-closed");
      });

      notifModal.addEventListener("click", (e) => {
        if (e.target === notifModal) {
          notifModal.classList.remove("modal-open");
          notifModal.classList.add("modal-closed");
        }
      });

      notifClearBtn.addEventListener("click", () => {
        notificationHistory = [];
        clearNotifications();
        renderNotificationHistory();
      });

      // Load Privacy Settings
      async function loadPrivacySettings() {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          console.log("[privacy] no uid");
          return;
        }

        try {
          console.log("[privacy] loading settings for uid:", uid);
          const snap = await db.ref("userPrivacy/" + uid).once("value");
          const privacy = snap.val() || {};
          
          console.log("[privacy] loaded:", privacy);
          allowFriendRequestsToggle.checked = privacy.allowFriendRequests !== false;
          allowDMsToggle.checked = privacy.allowDMs !== false;
        } catch (err) {
          console.error("[privacy] error loading settings:", err);
        }
      }

      // Save Privacy Settings
      savePrivacyBtn.addEventListener("click", async () => {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          alert("Not logged in");
          return;
        }

        savePrivacyBtn.disabled = true;
        savePrivacyBtn.textContent = "Saving...";

        try {
          console.log("[privacy] saving settings for uid:", uid);
          await db.ref("userPrivacy/" + uid).set({
            allowFriendRequests: allowFriendRequestsToggle.checked,
            allowDMs: allowDMsToggle.checked,
            updatedAt: firebase.database.ServerValue.TIMESTAMP
          });

          console.log("[privacy] saved successfully");
          savePrivacyBtn.textContent = "‚úì Saved!";
          savePrivacyBtn.style.background = "rgb(34, 197, 94)";

          setTimeout(() => {
            savePrivacyBtn.textContent = "Save Settings";
            savePrivacyBtn.style.background = "";
            savePrivacyBtn.disabled = false;
            privacySettingsModal.classList.remove("modal-open");
            privacySettingsModal.classList.add("modal-closed");
          }, 1500);
        } catch (err) {
          console.error("[privacy] error saving:", err);
          alert("Failed to save privacy settings: " + err.message);
          savePrivacyBtn.textContent = "Save Settings";
          savePrivacyBtn.disabled = false;
        }
      });

      // ===== DIRECT MESSAGES =====
      function openDmModal() {
        if (!currentUserId) {
          dmError.textContent = "Please log in.";
          return;
        }
        dmError.textContent = "";
        dmModal.classList.remove("modal-closed");
        dmModal.classList.add("modal-open");
        dmActiveUser.textContent = activeDMTarget?.username || "Select a conversation";
        
        // Show friends by default
        dmConversationList.innerHTML = '';
        showDmFriendsDefault();
      }

      function closeDmModal() {
        dmModal.classList.remove("modal-open");
        dmModal.classList.add("modal-closed");
        dmActiveUser.textContent = "Select a conversation";
        dmUserSearch.value = "";
        dmError.textContent = "";
        activeDMThread = null;
        activeDMTarget = null;
        dmConversationList.innerHTML = "";
        clearDmMessages();
        detachDmMessagesListener();
        detachDmInboxListener();
      }

      dmCloseBtn.addEventListener("click", closeDmModal);
      dmModal.addEventListener("click", (e) => {
        if (e.target === dmModal) {
          closeDmModal();
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && dmModal.classList.contains("modal-open")) {
          closeDmModal();
        }
      });

      // ===== FAST MODE (Performance) =====
      const fastModeToggle = document.getElementById("fastModeToggle");
      const fastModeLabel = document.getElementById("fastModeLabel");

      function applyFastMode(enabled, persist = true) {
        FAST_MODE_ENABLED = !!enabled;
        PAGE_SIZE = enabled ? 50 : 75;
        document.body.classList.toggle("perf-lite", enabled);
        if (persist) saveUserSetting("fastMode", enabled);
        if (fastModeLabel) {
          fastModeLabel.textContent = enabled ? "Fast Mode (ON)" : "Fast Mode";
        }
      }

      if (fastModeToggle) {
        fastModeToggle.addEventListener("change", () => {
          applyFastMode(fastModeToggle.checked, true);
        });
      }

      dmStartBtn.addEventListener("click", () => {
        startDmWithUsername(dmUserSearch.value);
      });

      dmUserSearch.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          startDmWithUsername(dmUserSearch.value);
        }
      });

      let dmSearchTimeout = null;
      dmUserSearch.addEventListener("input", () => {
        clearTimeout(dmSearchTimeout);
        const query = (dmUserSearch.value || "").trim();

        if (!query) {
          // Show all friends by default
          dmConversationList.innerHTML = '';
          showDmFriendsDefault();
          return;
        }

        dmConversationList.innerHTML = '<p class="text-xs text-slate-400 p-2">Searching...</p>';
        dmSearchTimeout = setTimeout(async () => {
          await searchDmUsers(query);
        }, 300);
      });

      async function showDmFriendsDefault() {
        const uid = auth.currentUser?.uid;
        if (!uid) return;

        try {
          const snap = await db.ref("friends/" + uid).once("value");
          const friends = snap.val() || {};
          const friendsList = Object.keys(friends);

          if (friendsList.length === 0) {
            dmConversationList.innerHTML = '<p class="text-xs text-slate-400 p-2">No friends yet</p>';
            return;
          }

          dmConversationList.innerHTML = '';

          for (const friendUid of friendsList) {
            const userSnap = await db.ref("users/" + friendUid + "/username").once("value");
            const username = userSnap.val() || friendUid;
            
            const profileSnap = await db.ref("userProfiles/" + friendUid).once("value");
            const profile = profileSnap.val() || {};
            const profilePic = profile.profilePic || '';

            const btn = document.createElement("button");
            btn.className = "w-full text-left px-3 py-2 rounded-lg bg-slate-800 hover:bg-slate-700 transition-colors flex items-center gap-3";
            btn.innerHTML = `
              <div class="w-10 h-10 rounded-full bg-slate-700 flex-shrink-0 overflow-hidden">
                ${profilePic ? `<img src="${profilePic}" class="w-full h-full object-cover">` : `<div class="w-full h-full flex items-center justify-center text-slate-400 text-sm">${username.charAt(0).toUpperCase()}</div>`}
              </div>
              <div class="text-sm text-slate-100">${username}</div>
            `;
            btn.onclick = () => {
              dmUserSearch.value = username;
              startDmWithUsername(username);
            };
            dmConversationList.appendChild(btn);
          }
        } catch (err) {
          console.error("[dm] error showing friends:", err);
          dmConversationList.innerHTML = '<p class="text-xs text-red-400 p-2">Error loading friends</p>';
        }
      }

      async function searchDmUsers(query) {
        if (!currentUserId) return;
        try {
          // Fetch usernames
          const usersSnap = await db.ref("users").once("value");
          const allUsers = usersSnap.val() || {};
          // Fetch profiles for avatars/bios
          const profilesSnap = await db.ref("userProfiles").once("value");
          const allProfiles = profilesSnap.val() || {};

          const q = query.toLowerCase();
          const matches = [];
          Object.entries(allUsers).forEach(([uid, val]) => {
            const uname = val?.username || "";
            if (!uname) return;
            if (uid === currentUserId) return;
            if (uname.toLowerCase().includes(q)) {
              const prof = allProfiles[uid] || {};
              matches.push({ uid, username: uname, bio: prof.bio, profilePic: prof.profilePic });
            }
          });

          if (!matches.length) {
            dmConversationList.innerHTML = '<p class="text-xs text-slate-400 p-2">No users found.</p>';
            return;
          }

          dmConversationList.innerHTML = "";
          matches.slice(0, 30).forEach((item) => {
            const btn = document.createElement("button");
            btn.className = "w-full text-left px-3 py-3 rounded-lg bg-slate-800 hover:bg-slate-700 transition-colors flex items-center gap-3";
            const avatar = document.createElement("div");
            avatar.className = "h-10 w-10 rounded-full bg-slate-700 flex items-center justify-center text-sm font-semibold text-slate-200 overflow-hidden";
            if (item.profilePic) {
              const img = document.createElement("img");
              img.src = item.profilePic;
              img.className = "h-full w-full object-cover";
              img.onerror = () => {
                avatar.textContent = (item.username || "?").charAt(0).toUpperCase();
              };
              avatar.appendChild(img);
            } else {
              avatar.textContent = (item.username || "?").charAt(0).toUpperCase();
            }

            const info = document.createElement("div");
            info.className = "flex-1 min-w-0";
            const name = document.createElement("div");
            name.className = "text-sm text-slate-100 font-semibold truncate";
            name.textContent = item.username;
            const bio = document.createElement("div");
            bio.className = "text-xs text-slate-400 truncate";
            bio.textContent = item.bio || "Tap to view profile";
            info.appendChild(name);
            info.appendChild(bio);

            const cta = document.createElement("span");
            cta.className = "text-[11px] text-slate-300";
            cta.textContent = "View & DM";

            btn.appendChild(avatar);
            btn.appendChild(info);
            btn.appendChild(cta);

            btn.onclick = () => {
              viewUserProfile(item.username, { silent: true });
              startDmWithUsername(item.username);
            };
            dmConversationList.appendChild(btn);
          });
        } catch (err) {
          console.error("[dm] search error", err);
          dmConversationList.innerHTML = '<p class="text-xs text-red-400 p-2">Search failed.</p>';
        }
      }

      dmForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        if (!currentUserId) {
          dmError.textContent = "Please log in.";
          return;
        }
        if (!activeDMTarget) {
          dmError.textContent = "Select a conversation first.";
          return;
        }
        if (blockedUsersCache.has(activeDMTarget.uid)) {
          dmError.textContent = "You blocked this user.";
          return;
        }

        if (await isBlockedByTarget(activeDMTarget.uid)) {
          dmError.textContent = "You are blocked by this user.";
          return;
        }

        const text = (dmInput.value || "").trim();
        if (!text) return;

        dmError.textContent = "";
        dmSendBtn.disabled = true;

        try {
          const allowSnap = await db
            .ref("userPrivacy/" + activeDMTarget.uid + "/allowDMs")
            .once("value");
          if (allowSnap.exists() && allowSnap.val() === false) {
            dmError.textContent = "This user is not accepting DMs.";
            dmSendBtn.disabled = false;
            return;
          }

          const threadId =
            activeDMThread || (await ensureDmThread(activeDMTarget.uid, activeDMTarget.username));
          const now = Date.now();
          const msg = {
            fromUid: currentUserId,
            toUid: activeDMTarget.uid,
            text,
            time: now,
            fromUsername: currentUsername || "",
            toUsername: activeDMTarget.username || "",
          };

          await db.ref("dms/" + threadId + "/messages").push(msg);

          // Update BOTH inboxes so recipient gets notified
          const myInboxUpdate = {
            withUid: activeDMTarget.uid,
            withUsername: activeDMTarget.username || activeDMTarget.uid,
            lastMsg: text,
            lastTime: now,
          };
          
          const theirInboxUpdate = {
            withUid: currentUserId,
            withUsername: currentUsername || currentUserId,
            lastMsg: text,
            lastTime: now,
          };
          
          await Promise.all([
            db.ref("dmInbox/" + currentUserId + "/" + threadId).set(myInboxUpdate),
            db.ref("dmInbox/" + activeDMTarget.uid + "/" + threadId).set(theirInboxUpdate),
            db.ref("dms/" + threadId + "/participants/" + activeDMTarget.uid).set(true).catch(() => {})
          ]);

          dmInput.value = "";
          dmSendBtn.disabled = false;
        } catch (err) {
          console.error("[dm] send error", err);
          dmError.textContent = err.message || "Failed to send DM.";
          dmSendBtn.disabled = false;
        }
      });

      async function blockActiveDmUser() {
        if (!currentUserId || !activeDMTarget?.uid) {
          dmError.textContent = "No conversation selected.";
          return;
        }
        const targetUid = activeDMTarget.uid;
        const targetUsername = activeDMTarget.username || "this user";
        if (!confirm(`Block ${targetUsername}?`)) return;

        try {
          await db.ref("blockedUsers/" + currentUserId + "/" + targetUid).set({
            blockedAt: firebase.database.ServerValue.TIMESTAMP,
            blockedUsername: targetUsername,
          });

          await loadBlockedUsersCache();
          dmError.textContent = `${targetUsername} blocked. You will not receive their DMs.`;
          closeDmModal();
        } catch (err) {
          console.error("[dm] block error", err);
          dmError.textContent = err.message || "Failed to block user.";
        }
      }

      dmBlockBtn.addEventListener("click", blockActiveDmUser);

      function applyMessageSize(size, persist = true) {
        const messagesContainer = document.getElementById("messages");
        messagesContainer.classList.remove("msg-small", "msg-large");
        if (size === "small") messagesContainer.classList.add("msg-small");
        if (size === "large") messagesContainer.classList.add("msg-large");
        if (persist) saveUserSetting("messageSize", size);
        console.log("[settings] message size set to", size);
      }

      function setActiveSizeButton(size) {
        document.querySelectorAll(".size-btn").forEach((b) => {
          const isActive = b.getAttribute("data-size") === size;
          b.classList.remove("active", "bg-sky-600", "hover:bg-sky-700", "text-white");
          b.classList.add("bg-slate-700", "hover:bg-slate-600", "text-slate-200");
          if (isActive) {
            b.classList.remove("bg-slate-700", "hover:bg-slate-600", "text-slate-200");
            b.classList.add("active", "bg-sky-600", "hover:bg-sky-700", "text-white");
          }
        });
      }

      // Message size buttons
      document.querySelectorAll(".size-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          const size = btn.getAttribute("data-size");
          setActiveSizeButton(size);
          applyMessageSize(size, true);
        });
      });

      // Theme buttons with light mode implementation
      function applyTheme(theme, persist = true) {
        if (theme === "light") {
          document.body.classList.add("light-mode");
        } else {
          document.body.classList.remove("light-mode");
        }
        if (persist) saveUserSetting("theme", theme);
        console.log("[settings] theme applied:", theme);
      }

      function setActiveThemeButton(theme) {
        document.querySelectorAll(".theme-btn").forEach((b) => {
          const isActive = b.getAttribute("data-theme") === theme;
          b.classList.remove("active", "bg-sky-600", "hover:bg-sky-700", "text-white");
          b.classList.add("bg-slate-700", "hover:bg-slate-600", "text-slate-200");
          if (isActive) {
            b.classList.remove("bg-slate-700", "hover:bg-slate-600", "text-slate-200");
            b.classList.add("active", "bg-sky-600", "hover:bg-sky-700", "text-white");
          }
        });
      }

      document.querySelectorAll(".theme-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          const theme = btn.getAttribute("data-theme");
          setActiveThemeButton(theme);
          applyTheme(theme);
        });
      });

      // Upload profile picture
      uploadPicBtn.addEventListener("click", () => {
        profilePicInput.click();
      });

      // Cloudinary upload function
      async function uploadToCloudinary(file) {
        const data = new FormData();
        data.append("file", file);
        data.append("upload_preset", "chat_upload");

        const res = await fetch("https://api.cloudinary.com/v1_1/dyi0oy0ce/upload", {
          method: "POST",
          body: data
        });

        const json = await res.json();
        
        // Check for Cloudinary error
        if (json.error) {
          console.error("[cloudinary] upload error:", json.error);
          throw new Error(json.error.message || "Cloudinary upload failed");
        }
        
        return json;
      }

      async function deleteFromCloudinary(token) {
        await fetch("https://api.cloudinary.com/v1_1/dyi0oy0ce/delete_by_token", {
          method: "POST",
          body: new URLSearchParams({ token })
        });
      }

      profilePicInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (file) {
          try {
            uploadPicBtn.disabled = true;
            uploadPicBtn.textContent = "Uploading...";

            // Upload to Cloudinary
            const upload = await uploadToCloudinary(file);
            const mediaUrl = upload.secure_url;
            const deleteToken = upload.delete_token;

            // Show preview
            profilePicPreview.innerHTML = "";
            const img = document.createElement("img");
            img.src = mediaUrl;
            img.className = "h-full w-full object-cover";
            profilePicPreview.appendChild(img);
            
            currentUserData.profilePic = mediaUrl;
            currentUserData.profilePicDeleteToken = deleteToken;

            uploadPicBtn.disabled = false;
            uploadPicBtn.textContent = "Upload Picture";
          } catch (err) {
            console.error("[profile] error uploading to cloudinary:", err);
            alert("Error uploading image: " + err.message);
            uploadPicBtn.disabled = false;
            uploadPicBtn.textContent = "Upload Picture";
          }
        }
      });

      // Load user profile data
      function loadUserProfile() {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          console.error("[profile] no user ID");
          return;
        }

        // Set username
        profileUsername.value = currentUsername || "";

        // Load from Firebase with error handling
        db.ref("userProfiles/" + uid).once(
          "value",
          (snap) => {
            const data = snap.val();
            if (data) {
              profileBio.value = data.bio || "";
              if (data.profilePic) {
                try {
                  profilePicPreview.innerHTML = "";
                  const img = document.createElement("img");
                  img.src = data.profilePic;
                  img.className = "h-full w-full object-cover";
                  img.onerror = () => {
                    console.warn("[profile] failed to load image");
                    setDefaultProfileIcon(profilePicPreview, 40);
                  };
                  profilePicPreview.appendChild(img);
                } catch (e) {
                  console.warn("[profile] error loading image:", e);
                  setDefaultProfileIcon(profilePicPreview, 40);
                }
              }
              currentUserData = { ...data };
              originalProfilePic = data.profilePic || null;
              originalProfilePicDeleteToken = data.profilePicDeleteToken || null;
              console.log("[profile] loaded successfully");
            } else {
              // Auto-create empty profile
              console.log("[profile] no profile exists, will create on save");
              profileBio.value = "";
              setDefaultProfileIcon(profilePicPreview, 40);
              currentUserData = {};
              originalProfilePic = null;
              originalProfilePicDeleteToken = null;
            }
          },
          (err) => {
            console.error("[profile] error loading profile:", err);
            alert("Could not load profile. Error: " + err.message);
            profileBio.value = "";
            currentUserData = {};
          }
        );
      }

      // View another user's profile
      async function viewUserProfile(username, options = {}) {
        console.log("[profile] viewing profile for", username);
        
        if (username === currentUsername) {
          // If it's their own profile, open the edit modal
          if (!options.silent) {
            profileOpenBtn.click();
          }
          return;
        }

        // Reset inline status message
        setFriendRequestStatus("");
        
        // Reset button states immediately
        sendFriendRequestBtn.disabled = false;
        sendFriendRequestBtn.style.background = "";
        sendFriendRequestBtn.textContent = "Add Friend";
        blockUserBtn.disabled = false;
        blockUserBtn.style.background = "";
        blockUserBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg> Block User';
        delete blockUserBtn.dataset.action;
        delete blockUserBtn.dataset.targetUid;

        // For other users, show custom read-only view
        viewProfileName.textContent = username || "-";
        viewProfileBio.textContent = "Loading...";
        viewProfilePic.innerHTML = generateDefaultAvatar(username);

        // Fetch user profile (non-blocking)
        setTimeout(() => {
          fetchUserProfile(username)
            .then((profile) => {
              if (profile?.profilePic) {
                try {
                  viewProfilePic.innerHTML = "";
                  const img = document.createElement("img");
                  img.src = profile.profilePic;
                  img.className = "h-full w-full object-cover rounded-full";
                  img.onerror = () => {
                    setDefaultProfileIcon(viewProfilePic, 64);
                  };
                  viewProfilePic.appendChild(img);
                } catch (e) {
                  // Keep default
                }
              }
              viewProfileBio.textContent = profile?.bio || "No bio yet";
            })
            .catch(() => {
              viewProfileBio.textContent = "No bio yet";
            });
        }, 0);

        // Check if you blocked them first (shows unblock button)
        await checkIfBlocked(username);
        
        // Then check friendship status and detect if they blocked you
        await checkFriendshipStatus(username);

        // Show admin actions if you're an admin
        showProfileAdminActions(username);

        if (!options.silent) {
          viewProfileModal.classList.remove("modal-closed");
          viewProfileModal.classList.add("modal-open");
        }
      }

      // Show/hide admin actions in profile based on admin status
      async function showProfileAdminActions(targetUsername) {
        const profileAdminActions = document.getElementById("profileAdminActions");
        const profileBanBtn = document.getElementById("profileBanBtn");
        const profileMuteBtn = document.getElementById("profileMuteBtn");
        const profileWarnBtn = document.getElementById("profileWarnBtn");
        const now = Date.now();
        const ownerUid = "u5yKqiZvioWuBGcGK3SWUBpUVrc2";
        const staffUid = "6n8hjmrUxhMHskX4BG8Ik9boMqa2";

        console.log("[admin-profile] isAdmin:", isAdmin, "targetUsername:", targetUsername);

        if (!isAdmin) {
          profileAdminActions.classList.add("hidden");
          return;
        }

        // Get target UID
        const snap = await db.ref("users").orderByChild("username").equalTo(targetUsername).once("value");
        if (!snap.exists()) {
          console.log("[admin-profile] target user not found");
          profileAdminActions.classList.add("hidden");
          return;
        }

        const targetUid = Object.keys(snap.val())[0];
        console.log("[admin-profile] targetUid:", targetUid, "currentUserId:", currentUserId);

        // Don't show admin actions for yourself
        if (targetUid === currentUserId) {
          profileAdminActions.classList.add("hidden");
          return;
        }

        // Protect owner from moderation actions
        if (targetUid === ownerUid) {
          profileAdminActions.classList.add("hidden");
          return;
        }

        // Staff cannot moderate other staff (only owner can)
        if (currentUserId === staffUid && targetUid === staffUid) {
          profileAdminActions.classList.add("hidden");
          return;
        }

        // Show admin actions
        console.log("[admin-profile] showing admin actions for", targetUsername);
        profileAdminActions.classList.remove("hidden");

        // Check ban status
        const banSnap = await db.ref("bannedUsers/" + targetUid).once("value");
        const banData = banSnap.val();
        const banExpired = banData && banData.until && banData.until <= now;
        if (banExpired) {
          clearExpiredBan(targetUid, banData);
        }
        const isBannedNow = !!(banData && (!banData.until || banData.until === 9999999999999 || banData.until > now));

        // Check mute status
        const muteSnap = await db.ref("mutedUsers/" + targetUid).once("value");
        const muteData = muteSnap.val();
        const isMutedNow = muteData && muteData.until && muteData.until > Date.now();
        console.log("[admin-profile] isMutedNow:", isMutedNow, "muteData:", muteData);

        // Set up button handlers
        profileBanBtn.textContent = isBannedNow ? "üö™ Unban" : "‚õî Ban";
        profileBanBtn.onclick = async () => {
          const latestBanSnap = await db.ref("bannedUsers/" + targetUid).once("value");
          const latestBan = latestBanSnap.val();
          const latestNow = Date.now();
          const latestActive = !!(latestBan && (!latestBan.until || latestBan.until === 9999999999999 || latestBan.until > latestNow));
          if (latestActive) {
            await unbanUser(targetUid);
            profileBanBtn.textContent = "‚õî Ban";
          } else {
            showBanReasonModal(targetUid);
          }
        };

        profileMuteBtn.onclick = () => {
          console.log("[admin-profile] mute button clicked, isMutedNow:", isMutedNow);
          if (isMutedNow) {
            // Unmute the user
            console.log("[admin-profile] unMuting user:", targetUid);
            db.ref("mutedUsers/" + targetUid).remove().then(() => {
              console.log("[admin-profile] user unmuted successfully");
              profileMuteBtn.textContent = "üîá Mute";
            }).catch((err) => {
              console.error("[mute] failed to unmute user", err);
            });
          } else {
            // Show mute modal
            showMuteReasonModal(targetUid);
          }
        };

        // Update button text based on mute status
        profileMuteBtn.textContent = isMutedNow ? "üîä Unmute" : "üîá Mute";

        profileWarnBtn.onclick = () => {
          showWarnReasonModal(targetUid);
        };
      }

      // Check if you're already friends and update the button
      async function checkFriendshipStatus(targetUsername) {
        const uid = auth.currentUser?.uid;
        if (!uid) return;

        try {
          // Lookup target UID
          const snap = await db.ref("users").orderByChild("username").equalTo(targetUsername).once("value");
          if (!snap.exists()) {
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
            return;
          }

          const targetUid = Object.keys(snap.val())[0];
          // Store for later use in button handlers
          sendFriendRequestBtn.dataset.targetUid = targetUid;
          sendFriendRequestBtn.dataset.targetUsername = targetUsername;

          // Check if you blocked them
          const youBlockedThem = await db.ref("blockedUsers/" + uid + "/" + targetUid).once("value");
          if (youBlockedThem.exists()) {
            sendFriendRequestBtn.disabled = true;
            sendFriendRequestBtn.style.background = "rgb(100, 116, 139)";
            sendFriendRequestBtn.textContent = "Blocked";
            setFriendRequestStatus("You have blocked this user.", "warn");
            return;
          }
          
          // Check target's privacy settings
          const privacySnap = await db.ref("userPrivacy/" + targetUid).once("value");
          const privacy = privacySnap.val() || {};
          
          if (privacy.allowFriendRequests === false) {
            sendFriendRequestBtn.disabled = true;
            sendFriendRequestBtn.style.background = "rgb(100, 116, 139)";
            sendFriendRequestBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="inline mr-1"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>Requests Disabled';
            setFriendRequestStatus("This user has disabled friend requests.", "warn");
            return;
          }

          // Check if already friends
          const friendsSnap = await db.ref("friends/" + uid + "/" + targetUid).once("value");
          if (friendsSnap.exists()) {
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.style.background = "rgb(220, 38, 38)";
            sendFriendRequestBtn.textContent = "Unfriend";
            sendFriendRequestBtn.dataset.action = "unfriend";
            return;
          }

          // Check if request already sent
          const sentReqSnap = await db.ref("friendRequests/" + targetUid + "/incoming/" + uid).once("value");
          if (sentReqSnap.exists()) {
            sendFriendRequestBtn.disabled = true;
            sendFriendRequestBtn.style.background = "rgb(100, 116, 139)";
            sendFriendRequestBtn.textContent = "‚è≥ Pending";
            setFriendRequestStatus("Friend request already sent.", "info");
            return;
          }

          // Check if they sent you a request
          const reverseReqSnap = await db.ref("friendRequests/" + uid + "/incoming/" + targetUid).once("value");
          if (reverseReqSnap.exists()) {
            sendFriendRequestBtn.disabled = true;
            sendFriendRequestBtn.style.background = "rgb(100, 116, 139)";
            sendFriendRequestBtn.textContent = "‚Ü© Incoming";
            setFriendRequestStatus("They sent you a friend request. Check your requests.", "info");
            return;
          }

          // Not blocked, not friends - enable add button
          sendFriendRequestBtn.disabled = false;
          sendFriendRequestBtn.style.background = "";
          sendFriendRequestBtn.textContent = "Add Friend";
          setFriendRequestStatus("");
        } catch (err) {
          console.error("[profile] error checking friendship status:", err);
          sendFriendRequestBtn.disabled = false;
          sendFriendRequestBtn.textContent = "Add Friend";
        }
      }

      // Generate default avatar with initials
      function generateDefaultAvatar(username) {
        const initial = (username || "?").charAt(0).toUpperCase();
        const colors = [
          "from-red-500 to-red-600",
          "from-blue-500 to-blue-600",
          "from-purple-500 to-purple-600",
          "from-green-500 to-green-600",
          "from-pink-500 to-pink-600",
          "from-indigo-500 to-indigo-600",
          "from-cyan-500 to-cyan-600",
          "from-amber-500 to-amber-600"
        ];
        const colorIdx = (username.charCodeAt(0) || 0) % colors.length;
        const color = colors[colorIdx];
        return `<div class="h-full w-full bg-gradient-to-br ${color} flex items-center justify-center text-4xl font-bold text-white">${initial}</div>`;
      }

      // Helper to set default profile picture SVG
      function setDefaultProfileIcon(element, size = 40) {
        const svg = `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>`;
        element.innerHTML = svg;
      }

      // Reset profile modal to edit mode when closing
      profileCloseBtn.addEventListener("click", () => {
        profileModal.classList.remove("modal-open");
        profileModal.classList.add("modal-closed");
        // Reset to edit mode
        setTimeout(() => {
          profileBio.disabled = false;
          profileBio.style.opacity = "1";
          saveProfileBtn.style.display = "block";
          uploadPicBtn.style.display = "block";
        }, 100);
      });

      profileModal.addEventListener("click", (e) => {
        if (e.target === profileModal) {
          profileModal.classList.remove("modal-open");
          profileModal.classList.add("modal-closed");
          // Reset to edit mode
          setTimeout(() => {
            profileBio.disabled = false;
            profileBio.style.opacity = "1";
            saveProfileBtn.style.display = "block";
            uploadPicBtn.style.display = "block";
          }, 100);
        }
      });

      // Close view profile modal
      viewProfileCloseBtn.addEventListener("click", () => {
        viewProfileModal.classList.remove("modal-open");
        viewProfileModal.classList.add("modal-closed");
      });

      viewProfileCloseBtn2.addEventListener("click", () => {
        viewProfileModal.classList.remove("modal-open");
        viewProfileModal.classList.add("modal-closed");
      });

      viewProfileModal.addEventListener("click", (e) => {
        if (e.target === viewProfileModal) {
          viewProfileModal.classList.remove("modal-open");
          viewProfileModal.classList.add("modal-closed");
        }
      });

      // Save profile
      saveProfileBtn.addEventListener("click", async () => {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          console.error("[profile] not logged in");
          alert("Not logged in. Please refresh and log in again.");
          return;
        }

        const newUsername = profileUsername.value.trim();
        const originalText = saveProfileBtn.textContent;
        
        // ===== COMPREHENSIVE USERNAME VALIDATION =====
        try {
          // Validate username is not empty
          if (!newUsername) {
            throw new Error("Username cannot be empty");
          }

          // Validate username length (3-12 characters)
          if (newUsername.length < 3) {
            throw new Error("Username too short (minimum 3 characters)");
          }

          if (newUsername.length > 12) {
            throw new Error("Username too long (maximum 12 characters)");
          }

          // Validate character set: only letters, numbers, underscore, dash
          if (!/^[a-zA-Z0-9_-]+$/.test(newUsername)) {
            throw new Error("Username can only contain letters, numbers, underscore (_) and dash (-)");
          }

          // Validate no leading or trailing special characters
          if (/^[_-]|[_-]$/.test(newUsername)) {
            throw new Error("Username cannot start or end with _ or -");
          }

          // Basic bad-word filter for usernames
          if (badWordPattern.test(newUsername)) {
            throw new Error("Username not allowed");
          }

          // Local blocked usernames list (client-side editable)
          if (isLocallyBlockedUsername(newUsername)) {
            throw new Error("Username not allowed");
          }

          // Validate bio length
          if (profileBio.value.length > 150) {
            throw new Error("Bio is too long (maximum 150 characters)");
          }

          // Check if username changed
          const usernameChanged = newUsername.toLowerCase() !== currentUsername.toLowerCase();

          if (usernameChanged) {
            // Show loading state
            saveProfileBtn.disabled = true;
            saveProfileBtn.textContent = "Checking username...";
            
            console.log("[profile] checking if username is taken:", newUsername);

            // Case-insensitive duplicate check
            const snapshot = await db.ref("users")
              .orderByChild("username")
              .once("value");

            let isTaken = false;
            snapshot.forEach((child) => {
              const existingUsername = child.val().username;
              const existingUid = child.key;
              // Check case-insensitive and exclude current user
              if (existingUsername.toLowerCase() === newUsername.toLowerCase() && existingUid !== uid) {
                isTaken = true;
              }
            });

            if (isTaken) {
              throw new Error("Username is already taken. Please choose another.");
            }

            // Username is available, proceed with update
            saveProfileBtn.textContent = "Saving...";

            // Update both profile and username paths
            const updates = {};
            updates["userProfiles/" + uid] = {
              username: newUsername,
              bio: profileBio.value.trim(),
              profilePic: currentUserData.profilePic || null,
              profilePicDeleteToken: currentUserData.profilePicDeleteToken || null,
              createdAt: currentUserData.createdAt || firebase.database.ServerValue.TIMESTAMP,
              updatedAt: firebase.database.ServerValue.TIMESTAMP,
            };
            updates["users/" + uid + "/username"] = newUsername;

            await db.ref().update(updates);

            // If profile picture changed and we have an old delete token, delete old asset
            if (
              originalProfilePic &&
              originalProfilePic !== currentUserData.profilePic &&
              originalProfilePicDeleteToken
            ) {
              try {
                await deleteFromCloudinary(originalProfilePicDeleteToken);
                console.log("[profile] deleted old profile image");
              } catch (e) {
                console.warn("[profile] failed to delete old profile image:", e);
              }
            }

            originalProfilePic = currentUserData.profilePic || originalProfilePic;
            originalProfilePicDeleteToken = currentUserData.profilePicDeleteToken || null;

            console.log("[profile] saved successfully with new username:", newUsername);
            currentUsername = newUsername;
            updateChatUserLabel(newUsername);
            
            // Clear profile cache so next load gets fresh data
            profileCache[newUsername] = null;
            
            // Success feedback
            saveProfileBtn.textContent = "‚úì Username Updated!";
            saveProfileBtn.style.background = "rgb(34, 197, 94)"; // green
            setTimeout(() => {
              saveProfileBtn.textContent = originalText;
              saveProfileBtn.style.background = "";
              saveProfileBtn.disabled = false;
            }, 2500);

          } else {
            // Username didn't change, just save bio and profile pic
            saveProfileBtn.disabled = true;
            saveProfileBtn.textContent = "Saving...";

            const userData = {
              username: currentUsername,
              bio: profileBio.value.trim(),
              profilePic: currentUserData.profilePic || null,
              profilePicDeleteToken: currentUserData.profilePicDeleteToken || null,
              createdAt: currentUserData.createdAt || firebase.database.ServerValue.TIMESTAMP,
              updatedAt: firebase.database.ServerValue.TIMESTAMP,
            };

            await db.ref("userProfiles/" + uid).set(userData);

            // If profile picture changed and we have an old delete token, delete old asset
            if (
              originalProfilePic &&
              originalProfilePic !== currentUserData.profilePic &&
              originalProfilePicDeleteToken
            ) {
              try {
                await deleteFromCloudinary(originalProfilePicDeleteToken);
                console.log("[profile] deleted old profile image");
              } catch (e) {
                console.warn("[profile] failed to delete old profile image:", e);
              }
            }

            originalProfilePic = currentUserData.profilePic || originalProfilePic;
            originalProfilePicDeleteToken = currentUserData.profilePicDeleteToken || null;

            console.log("[profile] saved successfully (no username change)");
            
            // Success feedback
            saveProfileBtn.textContent = "‚úì Profile Saved!";
            saveProfileBtn.style.background = "rgb(34, 197, 94)"; // green
            setTimeout(() => {
              saveProfileBtn.textContent = originalText;
              saveProfileBtn.style.background = "";
              saveProfileBtn.disabled = false;
            }, 2500);
          }

        } catch (err) {
          console.error("[profile] validation/save error:", err);
          
          // Determine button text based on error type
          let buttonText = "Error";
          if (err.message?.includes("taken")) {
            buttonText = "Username Taken";
          } else if (err.message?.includes("too short")) {
            buttonText = "Too Short";
          } else if (err.message?.includes("too long")) {
            buttonText = "Too Long";
          } else if (err.message?.includes("contain")) {
            buttonText = "Invalid Chars";
          } else if (err.message?.includes("start or end")) {
            buttonText = "Invalid Format";
          } else if (err.message?.includes("permission")) {
            buttonText = "Permission Denied";
          } else if (err.message?.includes("network")) {
            buttonText = "Network Error";
          }

          // Show error state
          saveProfileBtn.textContent = buttonText;
          saveProfileBtn.style.background = "rgb(239, 68, 68)"; // red

          setTimeout(() => {
            alert(err.message || "Error saving profile. Please try again.");
            saveProfileBtn.textContent = originalText;
            saveProfileBtn.style.background = "";
            saveProfileBtn.disabled = false;
          }, 1500);
        }
      });

      // ===== FRIEND REQUESTS =====
      let currentViewingUsername = null;

      const friendRequestsModal = document.getElementById("friendRequestsModal");
      const friendRequestsCloseBtn = document.getElementById("friendRequestsCloseBtn");
      const friendRequestsList = document.getElementById("friendRequestsList");
      const noFriendRequestsMsg = document.getElementById("noFriendRequestsMsg");
      const sendFriendRequestBtn = document.getElementById("sendFriendRequestBtn");
      const friendRequestStatus = document.getElementById("friendRequestStatus");

      function setFriendRequestStatus(text, variant = "info") {
        if (!friendRequestStatus) return;
        if (!text) {
          friendRequestStatus.classList.add("hidden");
          friendRequestStatus.textContent = "";
          return;
        }

        const variants = {
          info: "text-slate-200 bg-slate-800 border-slate-700",
          success: "text-emerald-100 bg-emerald-900/40 border-emerald-700/60",
          warn: "text-amber-100 bg-amber-900/30 border-amber-700/60",
          error: "text-rose-100 bg-rose-900/40 border-rose-700/60",
        };

        // Reset classes then apply
        friendRequestStatus.className = "text-xs rounded-lg px-3 py-2 mb-3 text-left border " + (variants[variant] || variants.info);
        friendRequestStatus.textContent = text;
        friendRequestStatus.classList.remove("hidden");
      }

      friendRequestsCloseBtn.addEventListener("click", () => {
        friendRequestsModal.classList.remove("modal-open");
        friendRequestsModal.classList.add("modal-closed");
      });

      friendRequestsModal.addEventListener("click", (e) => {
        if (e.target === friendRequestsModal) {
          friendRequestsModal.classList.remove("modal-open");
          friendRequestsModal.classList.add("modal-closed");
        }
      });

      // Load and display friend requests
      async function loadFriendRequests() {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          logDetailedError("loadFriendRequests", new Error("Not logged in"));
          return;
        }

        try {
          console.log("[friends] loading requests for uid:", uid);
          const snap = await db.ref("friendRequests/" + uid + "/incoming").once("value");
          const requests = snap.val() || {};
          const requestArray = Object.entries(requests).map(([fromUid, data]) => ({
            fromUid,
            timestamp: data.timestamp
          }));

          console.log("[friends] loaded", requestArray.length, "requests");

          friendRequestsList.innerHTML = "";

          if (requestArray.length === 0) {
            noFriendRequestsMsg.style.display = "block";
            sidePanelFriendBadge.classList.add("hidden");
            sidePanelFriendBadge.textContent = "0";
          } else {
            noFriendRequestsMsg.style.display = "none";
            sidePanelFriendBadge.classList.remove("hidden");
            sidePanelFriendBadge.textContent = requestArray.length;

            // Load usernames for each request
            for (const req of requestArray) {
              const div = document.createElement("div");
              div.className = "flex items-center justify-between p-3 bg-slate-700/50 rounded-lg";
              div.innerHTML = `
                <span class="text-sm font-medium text-slate-100">Loading...</span>
                <div class="flex gap-2">
                  <button class="accept-btn px-3 py-1 bg-sky-600 hover:bg-sky-700 text-white text-xs rounded-lg transition-colors" data-from-uid="${req.fromUid}">
                    Accept
                  </button>
                  <button class="reject-btn px-3 py-1 bg-slate-600 hover:bg-slate-500 text-slate-100 text-xs rounded-lg transition-colors" data-from-uid="${req.fromUid}">
                    Reject
                  </button>
                </div>
              `;
              friendRequestsList.appendChild(div);
              
              // Fetch username from UID
              try {
                const userSnap = await db.ref("users/" + req.fromUid + "/username").once("value");
                const fromUsername = userSnap.val() || "Unknown User";
                div.querySelector("span").textContent = fromUsername;
              } catch (err) {
                console.error("[friends] error loading username for:", req.fromUid, err);
                div.querySelector("span").textContent = "Unknown User";
              }
            }

            // Add event listeners
            friendRequestsList.querySelectorAll(".accept-btn").forEach((btn) => {
              btn.addEventListener("click", () => {
                const fromUid = btn.dataset.fromUid;
                console.log("[friends] accept button clicked for:", fromUid);
                acceptFriendRequest(fromUid);
              });
            });

            friendRequestsList.querySelectorAll(".reject-btn").forEach((btn) => {
              btn.addEventListener("click", () => {
                const fromUid = btn.dataset.fromUid;
                console.log("[friends] reject button clicked for:", fromUid);
                rejectFriendRequest(fromUid);
              });
            });
          }
        } catch (err) {
          logDetailedError("loadFriendRequests", err, { uid });
          alert("Error loading requests: " + err.message);
        }
      }

      // Send friend request
      sendFriendRequestBtn.addEventListener("click", async () => {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          logDetailedError("sendFriendRequest", new Error("Not logged in"));
          setFriendRequestStatus("Not logged in", "error");
          return;
        }
        
        // Check if this is an unfriend action
        if (sendFriendRequestBtn.dataset.action === "unfriend") {
          const targetUid = sendFriendRequestBtn.dataset.targetUid;
          const targetUsername = sendFriendRequestBtn.dataset.targetUsername;
          
          if (confirm(`Unfriend ${targetUsername}?`)) {
            try {
              console.log("[friends] unfriending:", targetUsername);
              
              // Remove from both friends lists
              await db.ref("friends/" + uid + "/" + targetUid).remove();
              await db.ref("friends/" + targetUid + "/" + uid).remove();
              
              console.log("[friends] unfriended successfully");
              
              // Reset button
              sendFriendRequestBtn.disabled = false;
              sendFriendRequestBtn.style.background = "";
              sendFriendRequestBtn.textContent = "Add Friend";
              delete sendFriendRequestBtn.dataset.action;
              delete sendFriendRequestBtn.dataset.targetUid;
              delete sendFriendRequestBtn.dataset.targetUsername;
              
              setFriendRequestStatus("Unfriended successfully", "success");
              setTimeout(() => setFriendRequestStatus(""), 2000);
            } catch (err) {
              logDetailedError("unfriend", err, { targetUid, targetUsername });
              setFriendRequestStatus("Error unfriending: " + err.message, "error");
            }
          }
          return;
        }
        
        if (!currentViewingUsername) {
          logDetailedError("sendFriendRequest", new Error("No username selected"));
          setFriendRequestStatus("No profile selected", "error");
          return;
        }

        if (currentViewingUsername === currentUsername) {
          setFriendRequestStatus("You can't send a request to yourself!", "warn");
          return;
        }

        let targetUid = null;
        try {
          console.log("[friends] sending request from:", currentUsername, "to:", currentViewingUsername);
          sendFriendRequestBtn.disabled = true;
          sendFriendRequestBtn.textContent = "Sending...";

          // Get target user's UID from username
          console.log("[friends] looking up target uid for username:", currentViewingUsername);
          const snap = await db.ref("users").orderByChild("username").equalTo(currentViewingUsername).once("value");
          if (!snap.exists()) {
            alert("User not found");
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
            return;
          }

          targetUid = Object.keys(snap.val())[0];
          console.log("[friends] found target uid:", targetUid);

          // Check target's privacy settings
          console.log("[friends] checking privacy settings for:", targetUid);
          const privacySnap = await db.ref("userPrivacy/" + targetUid).once("value");
          const privacy = privacySnap.val() || {};
          
          if (privacy.allowFriendRequests === false) {
            setFriendRequestStatus("This user has disabled friend requests.", "warn");
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
            return;
          }
          console.log("[friends] privacy check passed");

          // Check if you blocked them
          console.log("[friends] checking if you blocked them");
          const youBlockedThem = await db.ref("blockedUsers/" + uid + "/" + targetUid).once("value");
          if (youBlockedThem.exists()) {
            setFriendRequestStatus("You have blocked this user. Unblock them first.", "warn");
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
            return;
          }

          // Check if they blocked you (by trying to read their blocked list - but we can't, so we rely on server rules)
          // The server rules will reject if they blocked you, we just handle the error

          // Check if already friends
          console.log("[friends] checking if already friends");
          const alreadyFriends = await db.ref("friends/" + uid + "/" + targetUid).once("value");
          if (alreadyFriends.exists()) {
            setFriendRequestStatus("You're already friends!", "info");
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
            return;
          }

          // Check if already sent request
          console.log("[friends] checking for existing request at: friendRequests/" + targetUid + "/incoming/" + uid);
          const existingReq = await db.ref("friendRequests/" + targetUid + "/incoming/" + uid).once("value");
          if (existingReq.exists()) {
            setFriendRequestStatus("Friend request already sent!", "info");
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
            return;
          }

          // Check if they already sent you a request (reverse request)
          console.log("[friends] checking for reverse request at: friendRequests/" + uid + "/incoming/" + targetUid);
          const reverseReq = await db.ref("friendRequests/" + uid + "/incoming/" + targetUid).once("value");
          if (reverseReq.exists()) {
            setFriendRequestStatus("They already sent you a friend request. Check your requests.", "info");
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
            return;
          }

          // Send request (do NOT use ensureTargetFriendRequestsIncoming - it causes permission issues)
          console.log("[friends] writing request to: friendRequests/" + targetUid + "/incoming/" + uid);
          await db.ref("friendRequests/" + targetUid + "/incoming/" + uid).set({
            fromUid: uid,
            timestamp: firebase.database.ServerValue.TIMESTAMP
          });

          console.log("[friends] request sent successfully");
          sendFriendRequestBtn.textContent = "‚úì Sent!";
          sendFriendRequestBtn.style.background = "rgb(34, 197, 94)";
          
          setFriendRequestStatus("Friend request sent", "success");
          setTimeout(() => {
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
            sendFriendRequestBtn.style.background = "";
            setFriendRequestStatus("");
          }, 2000);
        } catch (err) {
          const errorInfo = logDetailedError("sendFriendRequest", err, {
            targetUsername: currentViewingUsername,
            currentUser: currentUsername,
            uid,
            targetUid: targetUid || "unknown"
          });

          let errorMsg = "Error sending request";
          let isBlocked = false;
          
          if (err.message?.includes("permission_denied") || err.code === "PERMISSION_DENIED") {
            // If we got past privacy check and still got permission denied, it's likely a block
            isBlocked = true;
            errorMsg = "You have been blocked by this user.";
            
            // Update button to reflect blocked state
            sendFriendRequestBtn.disabled = true;
            sendFriendRequestBtn.style.background = "rgb(185, 28, 28)";
            sendFriendRequestBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="inline mr-1"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg>You Have Been Blocked';
          } else if (err.message?.includes("network")) {
            errorMsg = "Network error - check your connection";
          }

          setFriendRequestStatus(errorMsg, isBlocked ? "error" : "error");
          if (!isBlocked) {
            sendFriendRequestBtn.disabled = false;
            sendFriendRequestBtn.textContent = "Add Friend";
          }
        }
      });

      // Accept friend request
      async function acceptFriendRequest(fromUid) {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          logDetailedError("acceptFriendRequest", new Error("Not logged in"), { fromUid });
          return;
        }

        try {
          console.log("[friends] accepting request from:", fromUid);

          // Auto-create both users' /friends paths
          console.log("[friends] ensuring /friends paths exist");
          await ensureTargetFriendsList(uid);
          await ensureTargetFriendsList(fromUid);

          console.log("[friends] removing request from:", fromUid);
          // Remove request
          await db.ref("friendRequests/" + uid + "/incoming/" + fromUid).remove();

          console.log("[friends] adding friend:", fromUid);
          // Add to friends list for both users (store UID only)
          await db.ref("friends/" + uid + "/" + fromUid).set({
            addedAt: firebase.database.ServerValue.TIMESTAMP
          });

          await db.ref("friends/" + fromUid + "/" + uid).set({
            addedAt: firebase.database.ServerValue.TIMESTAMP
          });

          console.log("[friends] request accepted successfully");
          loadFriendRequests();
        } catch (err) {
          logDetailedError("acceptFriendRequest", err, { fromUid, currentUid: uid });
          alert("Error accepting request: " + err.message);
        }
      }

      // Reject friend request
      async function rejectFriendRequest(fromUid) {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          logDetailedError("rejectFriendRequest", new Error("Not logged in"), { fromUid });
          return;
        }

        try {
          console.log("[friends] rejecting request from:", fromUid);
          await db.ref("friendRequests/" + uid + "/incoming/" + fromUid).remove();
          console.log("[friends] request rejected successfully");
          loadFriendRequests();
        } catch (err) {
          logDetailedError("rejectFriendRequest", err, { fromUid, currentUid: uid });
          alert("Error rejecting request: " + err.message);
        }
      }

      // Update viewUserProfile to track username
      const originalViewUserProfile = window.viewUserProfile;
      window.viewUserProfile = function(username) {
        currentViewingUsername = username;
        originalViewUserProfile.call(this, username);
      };

      // Load and display friends list
      async function loadFriendsList() {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          logDetailedError("loadFriendsList", new Error("Not logged in"));
          return;
        }

        try {
          console.log("[friends] loading friends for uid:", uid);
          const snap = await db.ref("friends/" + uid).once("value");
          
          const friendsList = document.getElementById("friendsList");
          const noFriendsMsg = document.getElementById("noFriendsMsg");
          friendsList.innerHTML = "";

          if (!snap.exists()) {
            console.log("[friends] no friends found");
            noFriendsMsg.style.display = "block";
            return;
          }

          const friends = snap.val();
          const friendCount = Object.keys(friends).length;
          console.log("[friends] loaded", friendCount, "friends");

          if (friendCount === 0) {
            noFriendsMsg.style.display = "block";
            return;
          }

          noFriendsMsg.style.display = "none";

          for (const [friendUid, friendData] of Object.entries(friends)) {
            // Check if you blocked them - skip if blocked
            const youBlockedThem = await db.ref("blockedUsers/" + uid + "/" + friendUid).once("value");
            
            if (youBlockedThem.exists()) {
              console.log("[friends] skipping blocked user:", friendUid);
              continue;
            }
            
            // Note: Can't check if they blocked you due to Firebase rules - but blocking already removes friendship

            const addedAt = new Date(friendData.addedAt).toLocaleDateString();

            const div = document.createElement("div");
            div.className = "p-3 bg-slate-800/60 hover:bg-slate-800 rounded-lg flex items-center justify-between transition-colors cursor-pointer border border-slate-700/50";
            
            const avatarDiv = document.createElement("div");
            avatarDiv.className = "h-10 w-10 rounded-full bg-gradient-to-br from-sky-500 to-sky-600 flex items-center justify-center text-white text-sm font-bold overflow-hidden flex-shrink-0";
            avatarDiv.innerHTML = "?";
            
            const infoDiv = document.createElement("div");
            infoDiv.className = "flex flex-col flex-1 ml-3";
            infoDiv.innerHTML = `
              <span class="text-sm font-medium text-slate-100">Loading...</span>
              <span class="text-xs text-slate-400">Added ${addedAt}</span>
            `;
            
            const container = document.createElement("div");
            container.className = "flex items-center gap-3 flex-1";
            container.appendChild(avatarDiv);
            container.appendChild(infoDiv);
            
            div.appendChild(container);
            
            // Fetch username from UID, then load profile picture
            (async () => {
              try {
                const userSnap = await db.ref("users/" + friendUid + "/username").once("value");
                const friendUsername = userSnap.val() || "Unknown";
                
                // Update display with username
                avatarDiv.innerHTML = friendUsername.charAt(0).toUpperCase();
                infoDiv.innerHTML = `
                  <span class="text-sm font-medium text-slate-100">${friendUsername}</span>
                  <span class="text-xs text-slate-400">Added ${addedAt}</span>
                `;
                
                // Load profile picture
                const profile = await fetchUserProfile(friendUsername);
                if (profile?.profilePic) {
                  try {
                    avatarDiv.innerHTML = "";
                    const img = document.createElement("img");
                    img.src = profile.profilePic;
                    img.className = "h-full w-full object-cover";
                    img.onerror = () => {
                      avatarDiv.innerHTML = friendUsername.charAt(0).toUpperCase();
                    };
                    avatarDiv.appendChild(img);
                  } catch (e) {
                    // Keep default
                  }
                }
                
                // Set click handler with current username
                div.addEventListener("click", () => {
                  friendsListModal.classList.remove("modal-open");
                  friendsListModal.classList.add("modal-closed");
                  viewUserProfile(friendUsername);
                });
                
              } catch (err) {
                console.error("[friends] error loading friend info:", err);
                infoDiv.innerHTML = `
                  <span class="text-sm font-medium text-slate-100">Unknown User</span>
                  <span class="text-xs text-slate-400">Added ${addedAt}</span>
                `;
              }
            })();
            
            friendsList.appendChild(div);
          }
        } catch (err) {
          logDetailedError("loadFriendsList", err, { uid });
          alert("Error loading friends: " + err.message);
        }
      }

      // ===== BLOCKING =====
      
      // Block/Unblock user
      blockUserBtn.addEventListener("click", async () => {
        const uid = auth.currentUser?.uid;
        if (!uid || !currentViewingUsername) {
          alert("No profile selected");
          return;
        }

        if (currentViewingUsername === currentUsername) {
          alert("You can't block yourself!");
          return;
        }

        // Check if this is an unblock action
        if (blockUserBtn.dataset.action === "unblock") {
          const targetUid = blockUserBtn.dataset.targetUid;
          
          if (!confirm(`Unblock ${currentViewingUsername}?`)) {
            return;
          }

          try {
            console.log("[block] unblocking user:", currentViewingUsername);
            blockUserBtn.disabled = true;
            blockUserBtn.textContent = "Unblocking...";

            await db.ref("blockedUsers/" + uid + "/" + targetUid).remove();

            console.log("[block] user unblocked successfully");
            blockUserBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg> Block User';
            blockUserBtn.style.background = "";
            delete blockUserBtn.dataset.action;
            delete blockUserBtn.dataset.targetUid;
            blockUserBtn.disabled = false;

            // Reload cache and refresh messages
            await loadBlockedUsersCache();
            startMessagesListener();

            // Re-check friendship status
            checkFriendshipStatus(currentViewingUsername);

            alert("User unblocked successfully");
          } catch (err) {
            console.error("[block] error unblocking user:", err);
            alert("Error unblocking user: " + err.message);
            blockUserBtn.disabled = false;
          }
          return;
        }

        if (!confirm(`Block ${currentViewingUsername}? They won't be able to send you messages or friend requests.`)) {
          return;
        }

        try {
          console.log("[block] blocking user:", currentViewingUsername);
          blockUserBtn.disabled = true;
          blockUserBtn.textContent = "Blocking...";

          // Get target UID
          const snap = await db.ref("users").orderByChild("username").equalTo(currentViewingUsername).once("value");
          if (!snap.exists()) {
            alert("User not found");
            blockUserBtn.disabled = false;
            blockUserBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg> Block User';
            return;
          }

          const targetUid = Object.keys(snap.val())[0];

          // Remove any pending friend requests FIRST (before blocking, so rules don't reject removal)
          try {
            await db.ref("friendRequests/" + uid + "/incoming/" + targetUid).remove();
          } catch (e) {
            console.log("[block] no incoming request from target");
          }
          try {
            await db.ref("friendRequests/" + targetUid + "/incoming/" + uid).remove();
          } catch (e) {
            console.log("[block] no outgoing request to target");
          }

          // Remove from friends if friends (both sides)
          await db.ref("friends/" + uid + "/" + targetUid).remove();
          await db.ref("friends/" + targetUid + "/" + uid).remove();

          // Add to blocked list LAST (so other removals don't get blocked by rules)
          await db.ref("blockedUsers/" + uid + "/" + targetUid).set({
            blockedAt: firebase.database.ServerValue.TIMESTAMP,
            blockedUsername: currentViewingUsername
          });

          console.log("[block] user blocked successfully");
          blockUserBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg> Unblock User';
          blockUserBtn.style.background = "rgb(100, 116, 139)";
          blockUserBtn.dataset.action = "unblock";
          blockUserBtn.dataset.targetUid = targetUid;
          blockUserBtn.disabled = false;

          sendFriendRequestBtn.disabled = true;
          sendFriendRequestBtn.style.background = "rgb(100, 116, 139)";
          sendFriendRequestBtn.textContent = "Blocked";

          // Reload cache and refresh messages to hide blocked user's messages
          await loadBlockedUsersCache();
          startMessagesListener();

          alert("User blocked successfully");
        } catch (err) {
          console.error("[block] error blocking user:", err);
          alert("Error blocking user: " + err.message);
          blockUserBtn.disabled = false;
          blockUserBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg> Block User';
        }
      });

      // Load blocked users list
      async function loadBlockedUsers() {
        const uid = auth.currentUser?.uid;
        if (!uid) {
          console.error("[block] not logged in");
          return;
        }

        try {
          console.log("[block] loading blocked users for uid:", uid);
          const snap = await db.ref("blockedUsers/" + uid).once("value");
          
          blockedUsersList.innerHTML = "";

          if (!snap.exists()) {
            noBlockedUsersMsg.style.display = "block";
            console.log("[block] no blocked users");
            return;
          }

          const blocked = snap.val();
          const blockedArray = Object.keys(blocked).map(blockedUid => ({
            blockedUid,
            ...blocked[blockedUid]
          }));

          console.log("[block] loaded", blockedArray.length, "blocked users");

          if (blockedArray.length === 0) {
            noBlockedUsersMsg.style.display = "block";
          } else {
            noBlockedUsersMsg.style.display = "none";

            for (const item of blockedArray) {
              const div = document.createElement("div");
              div.className = "flex items-center justify-between p-3 bg-slate-700/50 rounded-lg";
              div.innerHTML = `
                <span class="text-sm font-medium text-slate-100">Loading...</span>
                <button class="unblock-btn px-3 py-1 bg-sky-600 hover:bg-sky-700 text-white text-xs rounded-lg transition-colors" data-blocked-uid="${item.blockedUid}">
                  Unblock
                </button>
              `;

              blockedUsersList.appendChild(div);

              // Load username
              (async () => {
                try {
                  const usernameSnap = await db.ref("users/" + item.blockedUid + "/username").once("value");
                  const username = usernameSnap.val() || "Unknown User";
                  const blockedDate = new Date(item.blockedAt).toLocaleDateString();
                  
                  div.innerHTML = `
                    <div>
                      <span class="text-sm font-medium text-slate-100">${username}</span>
                      <span class="text-xs text-slate-400 block">Blocked ${blockedDate}</span>
                    </div>
                    <button class="unblock-btn px-3 py-1 bg-sky-600 hover:bg-sky-700 text-white text-xs rounded-lg transition-colors" data-blocked-uid="${item.blockedUid}">
                      Unblock
                    </button>
                  `;

                  // Unblock handler
                  const unblockBtn = div.querySelector(".unblock-btn");
                  unblockBtn.addEventListener("click", async () => {
                    if (!confirm(`Unblock ${username}?`)) return;

                    try {
                      console.log("[block] unblocking:", username);
                      await db.ref("blockedUsers/" + uid + "/" + item.blockedUid).remove();
                      console.log("[block] unblocked successfully");
                      
                      // Reload cache and refresh messages
                      await loadBlockedUsersCache();
                      startMessagesListener();
                      
                      // Reload blocked users list
                      loadBlockedUsers();
                    } catch (err) {
                      console.error("[block] error unblocking:", err);
                      alert("Error unblocking user: " + err.message);
                    }
                  });
                } catch (err) {
                  console.error("[block] error loading username:", err);
                  div.innerHTML = `
                    <span class="text-sm font-medium text-slate-100">Unknown User</span>
                    <button class="unblock-btn px-3 py-1 bg-sky-600 hover:bg-sky-700 text-white text-xs rounded-lg transition-colors" data-blocked-uid="${item.blockedUid}">
                      Unblock
                    </button>
                  `;
                }
              })();
            }
          }
        } catch (err) {
          console.error("[block] error loading blocked users:", err);
          alert("Error loading blocked users: " + err.message);
        }
      }

      // Check if viewing a blocked user
      async function checkIfBlocked(targetUsername) {
        const uid = auth.currentUser?.uid;
        if (!uid) return false;

        try {
          const snap = await db.ref("users").orderByChild("username").equalTo(targetUsername).once("value");
          if (!snap.exists()) return false;

          const targetUid = Object.keys(snap.val())[0];
          const blockedSnap = await db.ref("blockedUsers/" + uid + "/" + targetUid).once("value");
          
          if (blockedSnap.exists()) {
            blockUserBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg> Unblock User';
            blockUserBtn.style.background = "rgb(100, 116, 139)";
            blockUserBtn.dataset.action = "unblock";
            blockUserBtn.dataset.targetUid = targetUid;
            return true;
          } else {
            blockUserBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg> Block User';
            blockUserBtn.style.background = "";
            delete blockUserBtn.dataset.action;
            delete blockUserBtn.dataset.targetUid;
            return false;
          }
        } catch (err) {
          console.error("[block] error checking blocked status:", err);
          return false;
        }
      }

      // Friends list modal
      const friendsListModal = document.getElementById("friendsListModal");
      const friendsListCloseBtn = document.getElementById("friendsListCloseBtn");

      friendsListCloseBtn.addEventListener("click", () => {
        friendsListModal.classList.remove("modal-open");
        friendsListModal.classList.add("modal-closed");
      });

      friendsListModal.addEventListener("click", (e) => {
        if (e.target === friendsListModal) {
          friendsListModal.classList.remove("modal-open");
          friendsListModal.classList.add("modal-closed");
        }
      });

      // ===== USER SEARCH =====
      let searchTimeout = null;

      searchUsersInput.addEventListener("input", () => {
        clearTimeout(searchTimeout);
        const query = searchUsersInput.value.trim();

        if (query.length === 0) {
          searchResults.innerHTML = "";
          return;
        }

        if (query.length < 2) {
          searchResults.innerHTML = '<p class="text-xs text-slate-400 p-2">Type at least 2 characters...</p>';
          return;
        }

        searchResults.innerHTML = '<p class="text-xs text-slate-400 p-2">Searching...</p>';

        searchTimeout = setTimeout(async () => {
          await searchUsers(query);
        }, 300);
      });

      async function searchUsers(query) {
        const uid = auth.currentUser?.uid;
        if (!uid) return;

        try {
          console.log("[search] searching for:", query);
          
          // Search by username (case-insensitive partial match)
          const snap = await db.ref("users").once("value");
          const users = snap.val();
          
          if (!users) {
            searchResults.innerHTML = '<p class="text-xs text-slate-400 p-2">No users found</p>';
            return;
          }

          const results = [];
          const queryLower = query.toLowerCase();

          for (const [userId, userData] of Object.entries(users)) {
            if (userId === uid) continue; // Skip self
            
            const username = userData.username || "";
            if (username.toLowerCase().includes(queryLower)) {
              results.push({ uid: userId, username });
            }
          }

          if (results.length === 0) {
            searchResults.innerHTML = '<p class="text-xs text-slate-400 p-2">No users found</p>';
            return;
          }

          console.log("[search] found", results.length, "users");

          // Sort by username
          results.sort((a, b) => a.username.localeCompare(b.username));

          // Render results
          searchResults.innerHTML = "";

          for (const user of results) {
            const div = document.createElement("div");
            div.className = "flex items-center justify-between p-3 bg-slate-700/50 rounded-lg hover:bg-slate-700 transition-colors cursor-pointer";
            
            // Get profile pic
            const profileSnap = await db.ref("userProfiles/" + user.uid).once("value");
            const profile = profileSnap.val() || {};
            
            const avatarHTML = profile.profilePic
              ? `<img src="${profile.profilePic}" class="h-10 w-10 rounded-full object-cover" />`
              : generateDefaultAvatar(user.username);

            div.innerHTML = `
              <div class="flex items-center gap-3 flex-1">
                <div class="h-10 w-10 rounded-full overflow-hidden">
                  ${avatarHTML}
                </div>
                <div>
                  <p class="text-sm font-medium text-slate-100">${user.username}</p>
                  <p class="text-xs text-slate-400">${profile.bio || "No bio"}</p>
                </div>
              </div>
              <button class="add-friend-btn px-3 py-1 bg-sky-600 hover:bg-sky-700 text-white text-xs rounded-lg transition-colors" data-username="${user.username}">
                Add Friend
              </button>
            `;

            // Click on div to view profile
            const userInfoDiv = div.querySelector("div.flex-1");
            userInfoDiv.addEventListener("click", () => {
              viewUserProfile(user.username);
            });

            // Add friend button
            const addBtn = div.querySelector(".add-friend-btn");
            
            // Check friendship status
            (async () => {
              try {
                // Check if you blocked them
                const youBlockedThem = await db.ref("blockedUsers/" + uid + "/" + user.uid).once("value");
                if (youBlockedThem.exists()) {
                  addBtn.disabled = true;
                  addBtn.style.background = "rgb(100, 116, 139)";
                  addBtn.textContent = "Blocked";
                  return;
                }

                // Check privacy
                const privacySnap = await db.ref("userPrivacy/" + user.uid).once("value");
                const privacy = privacySnap.val() || {};
                
                if (privacy.allowFriendRequests === false) {
                  addBtn.disabled = true;
                  addBtn.style.background = "rgb(100, 116, 139)";
                  addBtn.textContent = "Disabled";
                  return;
                }

                // Check if already friends
                const friendsSnap = await db.ref("friends/" + uid + "/" + user.uid).once("value");
                if (friendsSnap.exists()) {
                  addBtn.disabled = true;
                  addBtn.style.background = "rgb(34, 197, 94)";
                  addBtn.textContent = "‚úì Friends";
                  return;
                }

                // Check if request already sent
                const sentReqSnap = await db.ref("friendRequests/" + user.uid + "/incoming/" + uid).once("value");
                if (sentReqSnap.exists()) {
                  addBtn.disabled = true;
                  addBtn.style.background = "rgb(100, 116, 139)";
                  addBtn.textContent = "Pending";
                  return;
                }

                // Check if they sent you a request
                const reverseReqSnap = await db.ref("friendRequests/" + uid + "/incoming/" + user.uid).once("value");
                if (reverseReqSnap.exists()) {
                  addBtn.disabled = true;
                  addBtn.style.background = "rgb(100, 116, 139)";
                  addBtn.textContent = "Incoming";
                  return;
                }
              } catch (err) {
                console.error("[search] error checking status:", err);
              }
            })();

            addBtn.addEventListener("click", async (e) => {
              e.stopPropagation();
              
              try {
                addBtn.disabled = true;
                addBtn.textContent = "Sending...";

                await db.ref("friendRequests/" + user.uid + "/incoming/" + uid).set({
                  fromUid: uid,
                  timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                addBtn.style.background = "rgb(34, 197, 94)";
                addBtn.textContent = "‚úì Sent!";
                
                setTimeout(() => {
                  addBtn.style.background = "rgb(100, 116, 139)";
                  addBtn.textContent = "Pending";
                }, 1500);
              } catch (err) {
                console.error("[search] error sending request:", err);
                alert("Error sending friend request: " + err.message);
                addBtn.disabled = false;
                addBtn.textContent = "Add Friend";
              }
            });

            searchResults.appendChild(div);
          }
        } catch (err) {
          console.error("[search] error:", err);
          searchResults.innerHTML = '<p class="text-xs text-red-400 p-2">Error searching users</p>';
        }
      }

      // Image Viewer
      const imageViewerModal = document.getElementById("imageViewerModal");
      const imageViewerImg = document.getElementById("imageViewerImg");
      const closeImageViewer = document.getElementById("closeImageViewer");

      function openImageViewer(imageUrl) {
        imageViewerImg.src = imageUrl;
        imageViewerModal.style.display = "flex";
        document.body.style.overflow = "hidden";
      }

      function closeImageViewerFunc() {
        imageViewerModal.style.display = "none";
        imageViewerImg.src = "";
        document.body.style.overflow = "";
      }

      closeImageViewer.addEventListener("click", (e) => {
        e.stopPropagation();
        closeImageViewerFunc();
      });

      imageViewerModal.addEventListener("click", closeImageViewerFunc);

      imageViewerImg.addEventListener("click", (e) => {
        e.stopPropagation();
      });

      // ESC key to close
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && imageViewerModal.style.display === "flex") {
          closeImageViewerFunc();
        }
      });

      // Delete Message Modal
      const deleteMessageModal = document.getElementById("deleteMessageModal");
      const cancelDeleteBtn = document.getElementById("cancelDeleteBtn");
      const confirmDeleteBtn = document.getElementById("confirmDeleteBtn");
      let pendingDeleteMessageId = null;
      let pendingDeleteToken = null;

      function openDeleteMessageModal(messageId, deleteToken) {
        pendingDeleteMessageId = messageId;
        pendingDeleteToken = deleteToken;
        deleteMessageModal.classList.remove("modal-closed");
        deleteMessageModal.classList.add("modal-open");
      }

      function closeDeleteMessageModal() {
        deleteMessageModal.classList.remove("modal-open");
        deleteMessageModal.classList.add("modal-closed");
        pendingDeleteMessageId = null;
        pendingDeleteToken = null;
      }

      cancelDeleteBtn.addEventListener("click", closeDeleteMessageModal);

      confirmDeleteBtn.addEventListener("click", async () => {
        if (!pendingDeleteMessageId) return;

        // Disable button and show loading state
        confirmDeleteBtn.disabled = true;
        confirmDeleteBtn.innerHTML = '<span class="animate-pulse">Deleting...</span>';

        try {
          await deleteMessage(pendingDeleteMessageId, pendingDeleteToken);
          
          // Show success state
          confirmDeleteBtn.innerHTML = '‚úì Deleted';
          confirmDeleteBtn.className = "flex-1 px-4 py-2 bg-green-600 text-white rounded-lg font-medium";
          
          setTimeout(() => {
            closeDeleteMessageModal();
            // Reset button state
            confirmDeleteBtn.disabled = false;
            confirmDeleteBtn.innerHTML = 'Delete';
            confirmDeleteBtn.className = "flex-1 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors font-medium";
          }, 800);
        } catch (err) {
          // Show error state
          confirmDeleteBtn.innerHTML = '‚úó Failed';
          confirmDeleteBtn.className = "flex-1 px-4 py-2 bg-orange-600 text-white rounded-lg font-medium";
          
          setTimeout(() => {
            confirmDeleteBtn.disabled = false;
            confirmDeleteBtn.innerHTML = 'Delete';
            confirmDeleteBtn.className = "flex-1 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors font-medium";
          }, 2000);
        }
      });

      // ESC key to close delete modal
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && deleteMessageModal.classList.contains("modal-open")) {
          closeDeleteMessageModal();
        }
      });

      // ===== SIDE PANEL MENU ITEMS =====
      // Initialize side panel menu items after all modals are declared
      
      sidePanelProfile.addEventListener("click", () => {
        closeSidePanel();
        loadUserProfile();
        profileModal.classList.remove("modal-closed");
        profileModal.classList.add("modal-open");
      });

      sidePanelSettings.addEventListener("click", () => {
        closeSidePanel();
        settingsModal.classList.remove("modal-closed");
        settingsModal.classList.add("modal-open");
      });

      sidePanelPrivacy.addEventListener("click", () => {
        closeSidePanel();
        loadPrivacySettings();
        privacySettingsModal.classList.remove("modal-closed");
        privacySettingsModal.classList.add("modal-open");
      });

      sidePanelFriendRequests.addEventListener("click", () => {
        closeSidePanel();
        friendRequestsModal.classList.remove("modal-closed");
        friendRequestsModal.classList.add("modal-open");
        loadFriendRequests();
      });

      sidePanelFriends.addEventListener("click", () => {
        closeSidePanel();
        friendsListModal.classList.remove("modal-closed");
        friendsListModal.classList.add("modal-open");
        loadFriendsList();
      });

      sidePanelDMs.addEventListener("click", () => {
        closeSidePanel();
        openDmModal();
      });

      sidePanelBlocked.addEventListener("click", () => {
        closeSidePanel();
        blockedUsersModal.classList.remove("modal-closed");
        blockedUsersModal.classList.add("modal-open");
        loadBlockedUsers();
      });
    </script>
  </body>
</html>
